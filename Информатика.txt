Практика информатика

Статические массивы

Массив - это последовательность элементов одного типа, которые:
    1) имеют одно имя
    2) имеют один тип данных
    3) пронумерованы по индексам (с нуля)
    А так же имеют номера (с единицы)

    Если кол-во элементов в массиве n (от 1 до n), то кол-во индексов тоже n (0, n-1)

int m[] {1,2,3,4,5}; - 5 элементов, значит занимает 5*4 байта = 20 байт
Резервирование памяти и её инициализация
int a[10];
for (int i = 0; i < 10; i++)
{
    cin >> a[i];
}

int m[10] {1,2,3,4,5} // остальные 5 элементов будут заполнены нулями {1,2,3,4,5,0,0,0,0,0}

функция sizeof(m); позволяет узнать объём памяти

Инициализация при помощи датчика случайных чисел

rand() - от 0 до 32767

a[i] = rand() % (2*n+1) - n диапазон (-n; n) включительно
позволяет выбрать диапазон чисел

для того чтобы каждый раз генерировались разные числа:
#include <time.h>
srand(time(NULL));

Тут должна быть блоксхема для нахождения макс элемента и его кол-ва и номера первого, за 1 проход в диапазоне от -100 до 99

Дано: 1 мерный массив целых чисел, проверить возрастает ли он?

int main()
{
    const int N = 10;
    int now;
    bool flag = true;
    int arr[N];
    for (int i = 0; i < N && flag; i++)
    {
        if (i == 0)
        {
            now = a[i]
        }
        if (now >= a[i])
        {
            flag = false;
            cout << false << endl;
        }
        else
        {
            now = a[i];
        }
    }
    if (flag)
    {
        cout << true << endl;
    }
}

Сделать лабу по этой задаче!!!
лабу в папку семместр 2 лаба 1


Анализ задачи:
1) Если бы мы шли по номерам, формула симм. элементов a = n-i+1


Лаба 2
Дано: одномерный массив целых чисел, перевернуть часть массива от элемента с индексом p до q, они симметричны
[1,2,3,4,5,6]
p = 1
q = 5
получим [1,5,4,3,2,6]
меняем от p до q

Лаба 3
Дано: одномерный массив целых чисел элементы циклически сдвинуть влево k раз
Анализ задачи:
    цилкы вложенные 
    внешний по k
    внутренний 

Лаба 4
в зелёной 
вариант 25



Дано одномерный массив целых чисел
    перед каждым чётным элементом поставить -1

Лекция 1
Методы сортировки массивов

    Метод сортировки - метод который изменяет порядок следования элементов в структуре данных

    Служат для:
        Обеспечения поиска
        Сравнения
        Обработки
        Увеличивают производительность и эффективность

    Метод обмена (пузырька)

    3 1 9 2 5

    необходимо совершить n-1 просмотра от первого до последнего

    for (int i = 0; i < size; i++)
    {
        for (int j = i; j < size - i; j++)
        {
            if (a[j] > a[j+1])
            {
                swap(a[j], a[j+1]);
            }
        }
    }

    1) просматриваем 2 соседних элемента массива двигаясь от его начала к концу
    2) Если левый больше правого, меняем местами
    3) В результате наибольший элемент окажется на n месте в массиве
    4) Так как на последнем месте максимальный элемент массива, он исключается из обработки
    5) выполняем такой просмотр n-1 раз, смотрим пары соседних элемнтов, начиная с первого до последнего элемента с номером, равному n-k, где k номер шага, в итоге получаем отсортированный массив


Метод выбора
    Алгоритм
        1) Находим в массиве минимальный элемент и меняем его местами с первым
        2) первый элемент исключаем из обработки
        3) находим минимальный элемент среди элементов с номером от 1 до n и меняем его со вторым элементом массива
        4) Продолжаем повторять поиск минимального элемента и его обмен с элементами  3-го по n-1

        int min;
        for (int i = 0; i < SIZE; i++)
        {
            min = i;

            // ищем минимальный элемент в массиве
            for (int j = i; j < SIZE; j++)
            {
                if (a[j] < a[min])
                {
                    min = j;
                }
            }

            // меняем i-ый элемент местами с минимальным
            swap(a[i], a[min]);
        }

Метод вставки

    Алгоритм
        1) массив делится на 2 части, первая часть отсортированная вторая часть не отсортированная
        2) элементы из не отсортированной части должны вставляться в отсортированную на то место, когда не нарушается порядок слеедования в отсортированной части (по убыванию или по возрастанию)
        3) на первом шаге в отсортированную часть входит только первый элемент массива
        4) берётся первый элемент из не отсортированной части и сравнивается последовательно со всеми элементами отсортированной части, начиная с её конца
        5) как только в отсортированной части находится место куда должен вставиться выбранный элемент (из неотсортированной части)
        6) все элементы их отсортированной части сдвигаются вправо на 1 место и выбранный элемент встаёт на своё найденное место, длинна отсортированной части увеличивается на 1 элемент

    for (int i = 0; i < SIZE - 1; i++)
    {

        // если элемент меньше левого, то меняем местами
        for (int j = i + 1; j>0 && a[j]<a[j-1];j--)
        {
            swap(a[j], a[j-1]);
        }   
    }

Многомерные массивы
        
    Это массив массивов каждый их которых управляется своей переменной
    Для доступа к элементу:
        int matrix[i][j];

    Инициализация многомерного массива возможна следующим образом:
        int matrix[][3] {{1,2,3}, {4,5,6}, {7,8,9}};
    int a[ROW][COL];
    for (int i = 0; i < ROW; i++)
    {
        for (int j = 0; j < COL; j++)
        {
            a[i][j] = rand()%10;
        }
    }
    for (int i = 0; i < ROW; i++)
    {
        for (int j = 0; j < COL; j++)
        {
            cout << a[i][j] << ' ';
            }
        cout << endl;
    }
    cout << endl;

Задача 1:
Составить таблицу умножения
for (int i = 0; i < ROW; i++)
{
    for (int j = 0; j < COL; j++)
    {
        a[i][j] = (i+1)*(j+1);
    }
}
Задача 2:
Найти максимальный элемент матрицы, его индексы и кол-во

int max = a[0][0], index_i, index_j, count;
    for (int i = 0; i < ROW; i++)
    {
        for (int j = 0; j < COL; j++)
        {
            if (a[i][j] > max)
            {
                max = a[i][j];
                index_i = i;
                index_j = j;
                count = 1;
            }
            else if (a[i][j] == max)
            {
                count++;
            }
            cout << a[i][j] << '\t';
        }
        cout << endl;
    }
    cout << endl;
    cout << "max: " << max << '\n' << "count:" << count << '\n' << "index_i: " << index_i << '\n' << "index_j: " << index_j << endl;


Практика 2
    
Рекурсия   
    Рекурсия - процесс повторения действий внутри этого элемента

    Рекурсивный алгоритм:
        1) одного или нескольких условий выхода из тела рекурсивной функции - базиса рекурсии
        2) шага рекурсии, который в конечном счёте должен приводить к выходу из рекурсии

    Простая рекурсия
        нахождение НОД двух чисел
            1) вводится 2 числа
            2) из большего вычитается меньшее
            3) снова выбирается большее
            4) цикл выполняется до тех пор пока 2 числа не станут равными

    Сложная рекурсия - это процесс в котором одна функия вызывает вторую, а та в свою очередь вызывает первую, первая функция должна вызывать ещё не описанную вторую функцию, для этого необходима сигнатура функции.

    Сигнатура функции - часть общего объявления функции, для компилятора и определения существования этой функции

    Структура сигнатуры:
        тип имя функции (тип переменные);
        Способ передачи параметров , по значению или по ссылке

    Дано - функции f, g - чему равно f(4) по формуле f(n) = f(n-1) + g(n-2)
    g(n) = g(n-1) + f(n-2) 
    при n>2
    иначе 1

    Хвостовая рекурсия

        Префиксная форма - сперва рекурсивный вызов, потом действия
        Пример - дано n, вывести числа от нуля до n

        Постфиксная - сперва действие, потом рекурсивный вызов

    Итерирование в рекурсиях

    Итерация - многократное поторение 

    + - рекурсии
        + программа коротка
        - переполнение стека

    Выполнить лабу без номера - рекурсии, вариант 25 (числа фибоначчи, ханойская башня, о восьми ферзях)

Числа фибоначчи - простая рекурсия

    ханойские
        3 стержня, на первом собраны все кольца по убванию диаметра к верху, необходимо, используя все 3 стержня перенести пирамидку на третий стрежень в том же поядке, можно ложить диск меньшего диаметра на диск большего, число ходов - наименьшее, перекладывать только по 1 диску
        1) перекладывание n-1 дисков на разрешённые стержни, свободный или на котором находится диск большего диаметра чем перекладываемый
        2) ищем место для освобождённого n-ого диска
        

Лекция 2
    
    Функции в c++
        Функции - блоки кода выполняющие определённые операции

        Возвращаемы_тип имя_функции (параметры)
        {
            тело_функции;
        }

ДЗ : разобраться с возможностью доступа к памяти в конкретной задаче
Прототип функции, что такое прототип функции, написать в коде, и что такое шаблон функции

        Прототип функции - только объявление функции перед main, а тело после main

        Тело функции можеть быть в другом файле

        тип имя(парметры); // прототип

        Правила работы с функциями

            1) тип данных выхода не может быть массивом или функцией
            2) тип функции зависит от типа выходных данных
            3) имя функции не может быть ключевым словом 
            4) нельзя определять функцию внутри другой функции

        Тип void в функциях

            void используется когда функция ничего не возвращает, отсутствует return;

            неправильное использование void:

                void func(int a, int b)
                {
                    return a+b;
                }

        Функция main()

            1) Точка начала выполнения программы
            2) стандарт типа функции main - int
            3) другие использования: void main(), int main(void)
            4) отсутствие return, если функция должна вернуть значенме - ошибка

        Параметры функций

            1) функции бывают вызвываемыми и вызывающими
                - вызывающая - main
                - вызываемая sum
                обмен параметрами между ними это главный маханизм работы функций

            2) виды параметров
                - формальные (в заголовке описания функции при объявлении)
                - фактические (аргуметны, в операторе вызова функии, функция буедт работать именно с ними)

            3) Способы передачи параметров в функию
                - по значению (функция работает с копиями аргументов, которые не могут изменить их исходные значения в main)
                    void f(int a, int b)
                    {
                        int c = a;
                        a = b;
                        b = c;
                    }
                - по адресу, по указателю (работа с копиями адресов аргументов, если изменить такую переменную, то она изменится в main)
                    void f(int* a, int* b)
                    {
                        int c = *a;
                        *a = *b;
                        *b = c;
                    }

        Использование классов памяти в функциях
                auto
                    - auto (для локальных переменных, по умолчанию int)
                    - для обозначение типов данных выхода и входа
                register
                    - для локальных перемменных
                    - записывает переменные в регистры процессора
                    - если места в регистрах нет - используется auto
                    inf f(int a, int b)
                    {
                        register int c;
                        c = a - b;
                        return c;
                    }
                    // пример работы с памятью

                static
                    - используется для объявления глобальных переменных внутри блока

                    void f()
                    {
                        static res = 1;
                        res++;
                        cout << res << endl;
                    }
                    если вызвать функцию 3 раза, то выведится: 2, 3, 4

                extern 
                    - для глобальных переменых для всей программы

                    extern int a = 1;

                    void f()
                    {
                        a++;
                    }
                    если вызвать функцию, то а увеличется на 1

        Передача массиваа в функцию
            В функцию передаётся указатель на первый элемент массива и кол-во элементов

            void func(int* arr, int SIZE)
            {
                ...;
            }

        Функции с переменным кол-вом параметров

            используется при неизвестном кол-ве параметров

            при описании функции явно должен быть указан хотя бы 1 параметр
            Как определить окончание, кол-во входных параметров
                1) задать в явном виде
                2) задать в виде признака окончания

                int summ(int m, ...) // m - явный параметр, обозначающий кол-во элементов
                {
                    int* p = &m + 1; // адрес следующего параметра
                    int sum = 0;
                    for (m; m != 0; m--)
                    {
                        sum += *p;
                        p++; // переход на следующий элемент параметров
                    }
                    return sum;
                }

                int summ(int m, ...) // пока один из параметров не стнет нулю, m - элемент последовательности
                {
                    int* p = &m;
                    int sum = 0;
                    while (*p)
                    {
                        sum += *p;
                        p++;
                    }
                    return sum;
                }
Д/З
лаба
7.1 - ф-ции с переменным числом параметров
7.2 - перегрузка // особое внимание на анализ задачи

        Перегрузка функций
            одна функция работает с разными типами данных

            Свойства
                1) перегруженные функции должны находиться в одной области видимости
                2) тип входных и выходных параметров отличается

        Шаблоны функций
            шаблоны вводятся для автоматизации создания перегруженных функций.
            С помощью шаблона перегруженная функция определяется один раз.

            template <typename параметр>
            переметр имя_функции(параметр входные_данные)
            {
                func_body;
            }

            cout << func<double>(a,b);


Пркатика
    Задача о 8 ферзях

        1) 1 ферзь должен стоять в каждой строке
        2) ни один ферзь не может бить любого другого
        3) реализовать алгоритм через рекурсивную функцию

        1) ставим в первую доступную, переход на след строку, снова в перую возможную
        2) так до конца, если не 8 ферзей, на строчку назад и ставим в другой возможной вариант, если его нет, то ещё на след клетку и так далее

Лекция
    Диаграммы функционального моделирования (SADT)
        Способ описания объекта (системы), которая позволяет выделить блоки активностей (отвечают за этапы работы системы) и СВЯЗИ (дуги), которые связывают блоки АКТИВНОСТЕЙ
        Результат:
            получение модели системы, для выстраивания алгоритма управления

        SADT - методология структурного анализа и проектирования (Steuctured Analysis and Design Technique)

        Этапы построения моделей системы
            1) Сбор информации с которой будеи работать
                - Опросы дял сбора фактов
                - Опросы для определения проблем
                - Совещания для принятия решений
            2) Определение цели и средства её достижения
            3) Декомпозиция и постороение диаграмм (разбивка на уровни управления)
            4) Критическая оценка, рецензирование и комментирование
            5) Признаки завершения декомпозиции - полнота модели
                - определение дополнительных возможностей для лучше детализации модели (очень абстрактная модель не читабельна, так как мало понятна)
                - отсутствие необходимости дальнейшей детализации (через изменение точки зрения понимания объекта)
                - SADT не терпит повторений, блоки не повторяются
                - блок представляет тривиальную функцию (чем более простую функцию реализует блок, тем быстрее модель превратится в код, программу)

        Правила составления диаграммы SADT
            1) состав диаграммы: блоки (Функции) и дуги (действия, связи), дуги могут изображать действия которые передаются от блока в блок
            2) Кол-во блоков ограничено: от 3 до 6-7, чтобы не путаться

        Изображение SADT моделей
            Блок, модель (ICOM: Input, Output, Control, Mechanism)
                Левая сторона: Вход (входные данные)    
                Правая сторона: Выход (результат выполнения процесса)
                Верхняя сторона: Управление (инструкции, указания, ограничения)
                Нижняя сторона: Механизмы (какие средства обеспецивают работу этого конкретного блока)
            Диаграммы располагаются в виде уровней для упрощения чтения диаграммы (Доминирование)
                Самый доминирующий блок раполагается в левом верхнем углу диаграммы

            Дуги в диаграммах IDF0
                1) взаимосвязь выход - управление между блоками
                2) выход - вход
                3) обратная связь по управлению
                4) обратная связь по входу
                5) выход - механизм

    Структуры в C++
        Структура - тип данных которых содаёт пользователь: имеет имя, структурирует разные типы переменных в одно целое
        Пример:
            Студент(Фио, группа, дата рождения)
            Метод - привязан к объекту, вызов через точку

        Объявление структуры:
            struct <name>
            {
                <field_of_structure>
            }
            struct human
            {
                int age;
                int weight; // Поля структуры
                string name; // функции -> Методы
            }
            Виды полей:
                - переменная
                - структура
                - массив
                - указатель
            Поле структуры не совпадает по типу с самой структурой, но указатель на саму структуру используется
            Обащение к структуре (->) для указателья, и (.) для переменной

            Инициализация полей

            int main()
            {
                Human Ivan;
                Ivan.age = 18;
                Ivan.name = "Ivan";
                Ivan.weight = 80;
                Ivan = {30, 80, "Ivan"};
                Human group_humans[30]; // массив этих структур
            }

            Работа с полями структуры 
            int main()
            {
                Human Ivan;
                Ivan.age = 18;
                Ivan.name = "Ivan";
                Ivan.weight = 80;
                cout << Ivan.age + Ivan.weight << endl; // Их можно сложить, а так же сравнивать

                // Ввод
                cin >> Ivan.name

                // Строку вводить лучше через getline();
                
            }

            Для создания экземпляра вложенной структуры используется ::
            struct galaxy
            {
                struct planet
                {
                    Характеристики
                }
            }
            galaxy::planet a;
            В структуре в которой находится вложенная структура, могут находится объекты этого поля
            
Указатели и динамические массивы
    Указатели в С++
        указатель - переменная которая хранит адрес ячейки памяти
        Тип привязан к переменной по адресу

        Указатель может быть константой или переменной.
        Указатель указывает на константу или переменную

        int n;
        const int m = 1;

        int* pn;
        const int* pn;
        int* const pn = &n;  // не изменить указатель, указатель - константа
        const int* const pm = &m; // указатель константа, на целую константу, нельзя из менить ни указатель, ни значение

        Виды указателей:
            Указатель на объект
                int* p; // тип не ссыка и не битовое поле
                    Битовое поле
                        Это поле некоторой структуры, содержит некоторое число битов
                        + экономия памяти
                    struct DateTime
                    {
                        unsigned short day: 5; // кол-во бит
                        unsigned short month: 4;
                        unsigned short year: 7;
                    }

            Ссылка
                Разыменованный указатель

            Указатель на функцию
                Это адрес по которомму передаётся упавление при вызове функции в коде программы
                    1) вызов через обращение к переменной которая хранит адрес функии
                    2) чтобы передать имя функции в другую функцию как параметр

                    int (*func)(double, int, ...);
                    тип имя_указателя типы_параметорв
                    имя_указателя = имя_функции // хранит вызов функции

            Указатель на void
                Когда сразу трудно определить, какой тип данных объекта будет хравниться в ячейке

                1) можно присваивать значение указателя любого типа
                2) можно сравнивать с любыми указателями
                3) Перед использованием void преобразуется к конкретному типу через static_cast

                int a = 7;

                void* p = &a; // указатель типа void не разыменовывается

                int* p = static_cast<int*> (p);

        Инициализация указателей
            1) с помощью разадресации
                int a = 5;
                int* pa = &a;

            2) с помощью другого указателя
                int* pa = &a;
                int* pb = pa;

            3) с помощью имени массива или функции, которые трактуются как адрес
                int arr[10];

                int* t = mas;
                void f(int a)
                {
                    ...
                }
                void (*pf)(int);
                pf = f;

            4) присваивание указателю адреса области памяти в явном виде
                char* p = (char*)0xB8000000;

            5) присвоение пустого значения
                int* s = NULL;
                int* s = 0;
                int* s = nullptr;


            6) Выделение участка динамической памяти и присваивание её адреса

                1) с помощью оператора new
                    int* n = new int;
                    int* m = new int(10);
                    int* q = new int[10];

                2) #include <malloc.h>
                    int* u = (int*)malloc(sizeof(int));

    Составные типы данных
        int* (*p[10])(); - массив из 10 указателей на функции которые не имеют параметров, и возвращают значение int
        1) чтение изнутри наружу
        2) квадратные и круглые скобки имеют одинаковый приоритет
        3) последним рассматривается спецификатор типа

        char* p;
        int* n;
        double* m;
        p++; // увелитися на 1 (так как 1 байт)
        n++; // уведитится на 4
        m++; // увеличится на 8

    Динамические массивы

        int size = 100;

        float* arr =  new float[size]; 100 значений флоат

        память освобождается delete [] arr;
        если malloc, то free(arr);

        освобождать необходимо обязательно, иначе утечка памяти

    Перечислимый тип данных
        Это значения символьных констант
        1) не требует выделения памяти
        2) память выделяется когда переменная этого типа определена

        enum Colors
        {
            RED,
            WHITE,
            BLACK,
            BLUE,
        };

        Имена в разных перечислителях enum не повторяется

        В перечислителях можно создавать их классы

        enum class A
        {
            A,
            B,
        };

        enum class B
        {
            A,
            B,
        };

        Каждому перечислителю присваивается значение
        enum Colors
        {
            COLOR_RED, // 0
            COLOR_WHITE, // 1
            COLOR_BLACK, // 2
            COLOR_BLUE, // 3
        };

        enum Animals
        {
            ANIMAL_PIG = -4,
            ANIMAL_WOLF, // -3
            ANIMAL_CAT = 6,
            ANIMAL_DOG = 6,
            ANIMAL_HORSE, // 7
        };

        если не определено, то оно будет иметь значение на 1 больше предыдущего
        Если 2 определителя получили одинаковое значение в одном enum, то это делать не рекомендуется 


        Обработка enum
            1) т.к. значения - целые числа, то их можно выводить в консоль, и присваивать int
            2) компилятор не конверитрует самостоятельно значения перечислителей
            3) нельзя ввести перечислитель через cin
            4) присвоение значения перечислителя из одного enum перечислителю из другого делать нельзя

        Приведение типов данных
            Это процесс изменения типа данных объекта
            бывает явным и неявным:
                Неявное:
                    int a = 6;
                    double b = a;

                    char a = 'n';
                    int b = a; // в ASCII
                Явное:
                    double a = 132.6893;
                    int b = (int)a; // 133

        Освобождение динамической памяти
            int* arr = new arr[50];
            delete [] arr;

            Удаление необходимо осуществлять в области видимости
            for (int i = 0; i < 5; i++)
            {
                int* a = new int;
                *a = 10 + i;
                cout << *a << endl;
            }
            delete a; // ошибка

            Если указателю присвоить значение другого указателя, при этом не освободив динамическую память, произойдёт утечка

            int* a = new int;
            *a = 10;
            int b = 20;
            cout << *a << endl;
            a = &b;
            cout << *a << endl;
            delete a; // удалится не то что нужно, нужно поставить перед присвоением a другого адреса

        Многомерные динамические массивы
            это массив указателей на массивы
            int* a[count_row] - каждая строка - массив
            int a[count_row][count_col]

            Создание:
                1)
                    int row = 5;
                    int** arr = (int**) new int[row][10] // это %№?%*
                2)
                    cin >> row >> col;
                    int** a = new int* [row]; // nice
                    for (int i = 0; i < row; i++)
                    {
                        a[i] = new int[col]
                    }
                    for (int i = 0; i < row; i++)
                    {
                        delete [] a[i];
                    }
                    delete [] a;
Лекция
    Динамические структуры данных. Одно и двунаправленные списки
        Динамическая структура - это объект который работает с динамической памятью
        Обычно динамическая память выделяется сегменатми(блоками)
        Блок(node) - это поля и сввязи между ними
        Для описания node и создаётся динамическая структура через систему указателей
        Если node не ссылается на другие, то указателю на него присвается значение nullptr

        Списки
            Однонаправленные
                node (данные, указатель) указывает не блок следующего узла
                1) работа с node организована через список
                2) если есть классификация в коде, то список этой классификации имеет поле с указателем на начальный узел
                3) возможно создать указатель на любой нужный для заадчи узел

                экземпляр списка -> указатель на головной узел -> головной узел -> узел -> узел -> последний узел хранит нулевой указатель 
                (Стрелочка -> - указатель на следующий нод)

                struct Node 
                {
                    int data;
                    Node* pointer_to_next_node = nullptr;
                };

                struct List
                {
                    Node* head_node = nullptr;
                };

                // Добавление элементов в конец списка

                void pushBack(List& list, const int& data)
                {
                    Node* new_node = new Node; // динамически создаём новый узел
                    new_node -> data = data; // Присваиваем полю узла data данные

                    if (list.head_node == nullptr) // если список пуст
                    {
                        // новый узел становится головным узлом списка
                        list.head_node = new_node;
                    }
                    else
                    {
                        // берём в качестве текущего узла начальный
                        Node* current_node = list.head_node;

                        // пока не найдём последний узел в списке
                        while (current_node->pointer_to_next_node != nullptr)
                        {
                            // переходим к следующему узлу
                            current_node = current_node->pointer_to_next_node;
                        }
                        current_node->pointer_to_next_node = new_node;
                    }
                }

                ---------------------
                ...
                struct List
                {
                    Node* head_node = nullptr;
                    Node* tail_node = nullptr;
                };

                // Добавление элементов в конец списка

                void pushBack(List& list, const int& data)
                {
                    Node* new_node = new Node; // динамически создаём новый узел
                    new_node -> data = data; // Присваиваем полю узла data данные

                    if (list.head_node == nullptr) // если список пуст
                    {
                        list.head_node = new_node;
                        list.tail_node = new_node;
                    }
                    else
                    {
                        list.tail_node->pointer_to_next_node = new_node;
                        list.tail_node = new_node
                    }
                }

                // добавление и вывод
                int main()
                {
                    List list;

                    for (int i = 0; i != 7; i++)
                    {
                        pushBack(list, i*i);
                    }
                    Node* current_node = list.head_node;
                    while (current_node != nullptr)
                    {
                        cout << current_node->data << ' ';
                        current_node = current_node->pointer_to_next_node;
                    }
                }
                ------------------------------------------
                // удаление из списка
                void popFront(List& list)
                {
                    if (list.head_node == nullptr)
                    {
                        return;
                    }
                    Node* remove = list.head_node;

                    list.head_node = list.head_node->pointer_to_next_node;

                    if (remove == list.tail_node)
                    {
                        list.tail_node = nullptr;
                    }

                    delete remove;
                }

            Двусвязные списки
                указатель на главный узел -> головной узел <-> узел <-> узел <-> хвостовой узел <- указатель на хвостовой узел

                struct Node
                {
                    int data;
                    Node* pointer_to_preview_node = nullptr;
                    Node* pointer_to_next_node = nullptr;

                };

                struct List
                {
                    Node* head_node = nullptr;
                    Node* tail_node = nullptr;
                }; 

                //вставка элемента на индекс 
                void insertItem(List& list, const int& data, const int& index = 0)
                {
                    Node* new_node = new Node;
                    new_node->data = data;

                    if (list.head_node == nullptr)
                    {
                        list.head_node = new_node;
                        list.tail_node = new_node;
                        return;
                    }

                    int counter = 0;
                    Node* current_node = list.head_node;
                    while (counter != index)
                    {
                        current_node = current_node->pointer_to_next_node;
                        counter++;
                    }

                    new_node->pointer_to_preview_node = current_node;
                    if (current_node->pointer_to_next_node != nullptr)
                    {
                        new_node->pointer_to_next_node = current_node->pointer_to_next_node;
                        current_node->pointer_to_next_node->pointer_to_preview_node = new_node;
                    }
                    current_node->pointer_to_next_node = new_node;
                    list.tail_node = new_node;

                }
        Стеки
            Стек - это линейная структура данных, когда добавление и удаление элементов идёт с вершиный стека

            Как стопка тарелок, добавить и убрать можно только сверху
            Принцип LIFO (last in first out)

            Стек, как односвязный список
            Единицей стека является узел
            Элемент стека - это узел, который содержит: данные, указатель на следующий узел, собственный адрес с помощью которого элементы связаны друг с другом

            Первый, верхний элемент - head
            Размер стека - size, кол-во элементов в стеке

            nullptr - признак окончания

            Объявление стека

            template <class T>
            struct Node
            {
                T data;
                Node<T>* next_ptr;
            };

            template <class T>
            struct Stack
            {
                Node<T>* head;
                int size;
            };

            template <class T>
            void SetNode(Node<T>*& node, T data = T(), Node<T>* next_ptr = nullptr)
            {
                node = new Node<T>();
                node->next_ptr = next_ptr;
                node->data = data;
            }

            template <class T>
            void SetStack(Stack<T>& tmp)
            {
                tmp.head = nullptr;
                tmp.size = 0;
            }

            template <class T>
            void Push(Stack<T>& tmp, const T& data)
            {
                Node<T>* new_node;
                SetNode(new_node, data, tmp.head); // tmp.head текущаю вершина стека

                // меняем указатель на новую голову стека, новый узел - голова
                tmp.head = new_node;
                tmp.size++;
            }

            template <class T>
            void Pop(Stack<T>& tmp)
            {
                if (tmp.head == nullptr)
                {
                    Node<T>* delete_element = tmp.head;

                    tmp.head = tmp.head -> next_ptr;

                    delete delete_element;

                    tmp.size--;
                }
            }

        Очереди
            Работает по принципу (first in first out FIFO)

            Добавление в конец, а выход из начала

            Структура очереди - узел очереди 
                1) Данные
                2) указатель на следующий элемент очереди 

            Последний элемент указывает на nullptr

            template <class T>
            struct Node
            {
                T data;
                Node<T>* next;
            };

            template <class T>
            struct Queue
            {
                int size;
                Node<T>* head;
                Node<T>* tail;
            };

            template <class T>
            void init_queue(Queue<T>& q, const T& value)
            {
                Node<T>* new_node = new Node<T>();
                new_node->data = value;
                q.head = new_node;
                q.tail = new_node;
                q.size = 1;
            }

            template <class T>
            void push(Queue<T>& q, const T& value)
            {
                Node<T>* = new Node<T>();
                q.size++;
                new_node->data = value;
                new_node->next = nullptr;
                q.tail->next = new_node;
                q.tail = new_node;
            }

            template <class T>
            void new_queue(Queue<T>& q, int n)
            {
                T a;
                cout << "Введите элемент: ";
                cin >> a;
                init_queue(q, a);
                for (int i = 2; i <= n; i++)
                {
                    cout << "Введите элемент: ";
                    cin >> a;
                    push(q, a);
                }
            }

            template <class T>
            void delete_queue(Queue<T>& q)
            {
                while (q.head->next != nullptr)
                {
                    pop(q); // своя функция
                }
                Node<T>& tmp = q.head;
                q.head = nullptr;
                q.size--;
                delete tmp;
            }


Практика 

    Сортировки

        Сортировка слиянием 
            В алгоритме происходит декомпозиция задачи на несколько мелких, которые решаются просто

            Сортировка слиянием декомпозирует массив до тех пор пока каждый участок не будет состоять только из 1 элемента, которые легко расставить по критерию сортировки


            Алгоритм сортировки слиянием
                1) необходимо 2 функции: разделение массива на группы, слияние в требуемом порядке
                2) особеноости: в методе слияния декомпозиция и сортировка будут идти независимо от того, отсортирован исходный массив или нет
                3) необходима дополнительная память

        Быстрая сортировка
            Выбирается ключевой элемент который делит исходный массив на 2 части

            Перемещаем все элементы меньше ключевого влево, а больше вправо

            Повторяем выбор ключевых элементов для левой и правой части пока ключевым не останется 1 элемент

        Сортировка подсчётом 
            Метод работает если: 
                сортируются целые числа
                кол-во их разнообразия не высокая, например числа от 0 до 1000
                много повторяющихся элементов
                небольшой диапазон разброса элементов

            Алгоритм:  
                1) находим максимальным и минимальный элемент
                2) считаем кол-во элементов у каждого ключа (становится известна длина массива)

        Блочная сортировка
            Разделям массив на несколько блоков по числовому диапазону после того как отсортировали блоки сливаем их в один массив


        Метод Шелла
            1) находи центральный элемент (pivot)
            индекс центрального элемента - шаг (step)
            2) Определяем блоки элементов (длина блока - step)
            3) создаём блоки из 2 элементов отстающих друг от друга на step
            4) попарно сравниваем элементы и меняем их местами
            5) новый step = step / 2

        Сортировка Хоара
            1) опорный элемент - центр массива
            2) устанавливаем левый и правый индекс массива (левый = 0, правый = size-1)

            Основа алгоритма, в левую часть от опорного перемещаются все элементы менбше него а в правую часть все элементы больше него

            Сравниваем элемент под left с middle, если left меньше то left увеличиваем на 1
            если left больше, то проход слева останавливается

            Дальше начинаем идти справа, если справа попадётся меньше, то останавливаем

            
