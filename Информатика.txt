Практика информатика

Статические массивы

Массив - это последовательность элементов одного типа, которые:
    1) имеют одно имя
    2) имеют один тип данных
    3) пронумерованы по индексам (с нуля)
    А так же имеют номера (с единицы)

    Если кол-во элементов в массиве n (от 1 до n), то кол-во индексов тоже n (0, n-1)

int m[] {1,2,3,4,5}; - 5 элементов, значит занимает 5*4 байта = 20 байт
Резервирование памяти и её инициализация
int a[10];
for (int i = 0; i < 10; i++)
{
    cin >> a[i];
}

int m[10] {1,2,3,4,5} // остальные 5 элементов будут заполнены нулями {1,2,3,4,5,0,0,0,0,0}

функция sizeof(m); позволяет узнать объём памяти

Инициализация при помощи датчика случайных чисел

rand() - от 0 до 32767

a[i] = rand() % (2*n+1) - n диапазон (-n; n) включительно
позволяет выбрать диапазон чисел

для того чтобы каждый раз генерировались разные числа:
#include <time.h>
srand(time(NULL));

Тут должна быть блоксхема для нахождения макс элемента и его кол-ва и номера первого, за 1 проход в диапазоне от -100 до 99

Дано: 1 мерный массив целых чисел, проверить возрастает ли он?

int main()
{
    const int N = 10;
    int now;
    bool flag = true;
    int arr[N];
    for (int i = 0; i < N && flag; i++)
    {
        if (i == 0)
        {
            now = a[i]
        }
        if (now >= a[i])
        {
            flag = false;
            cout << false << endl;
        }
        else
        {
            now = a[i];
        }
    }
    if (flag)
    {
        cout << true << endl;
    }
}

Сделать лабу по этой задаче!!!
лабу в папку семместр 2 лаба 1


Анализ задачи:
1) Если бы мы шли по номерам, формула симм. элементов a = n-i+1


Лаба 2
Дано: одномерный массив целых чисел, перевернуть часть массива от элемента с индексом p до q, они симметричны
[1,2,3,4,5,6]
p = 1
q = 5
получим [1,5,4,3,2,6]
меняем от p до q

Лаба 3
Дано: одномерный массив целых чисел элементы циклически сдвинуть влево k раз
Анализ задачи:
    цилкы вложенные 
    внешний по k
    внутренний 

Лаба 4
в зелёной 
вариант 25



Дано одномерный массив целых чисел
    перед каждым чётным элементом поставить -1

Лекция 1
Методы сортировки массивов

    Метод сортировки - метод который изменяет порядок следования элементов в структуре данных

    Служат для:
        Обеспечения поиска
        Сравнения
        Обработки
        Увеличивают производительность и эффективность

    Метод обмена (пузырька)

    3 1 9 2 5

    необходимо совершить n-1 просмотра от первого до последнего

    for (int i = 0; i < size; i++)
    {
        for (int j = i; j < size - i; j++)
        {
            if (a[j] > a[j+1])
            {
                swap(a[j], a[j+1]);
            }
        }
    }

    1) просматриваем 2 соседних элемента массива двигаясь от его начала к концу
    2) Если левый больше правого, меняем местами
    3) В результате наибольший элемент окажется на n месте в массиве
    4) Так как на последнем месте максимальный элемент массива, он исключается из обработки
    5) выполняем такой просмотр n-1 раз, смотрим пары соседних элемнтов, начиная с первого до последнего элемента с номером, равному n-k, где k номер шага, в итоге получаем отсортированный массив


Метод выбора
    Алгоритм
        1) Находим в массиве минимальный элемент и меняем его местами с первым
        2) первый элемент исключаем из обработки
        3) находим минимальный элемент среди элементов с номером от 1 до n и меняем его со вторым элементом массива
        4) Продолжаем повторять поиск минимального элемента и его обмен с элементами  3-го по n-1

        int min;
        for (int i = 0; i < SIZE; i++)
        {
            min = i;

            // ищем минимальный элемент в массиве
            for (int j = i; j < SIZE; j++)
            {
                if (a[j] < a[min])
                {
                    min = j;
                }
            }

            // меняем i-ый элемент местами с минимальным
            swap(a[i], a[min]);
        }

Метод вставки

    Алгоритм
        1) массив делится на 2 части, первая часть отсортированная вторая часть не отсортированная
        2) элементы из не отсортированной части должны вставляться в отсортированную на то место, когда не нарушается порядок слеедования в отсортированной части (по убыванию или по возрастанию)
        3) на первом шаге в отсортированную часть входит только первый элемент массива
        4) берётся первый элемент из не отсортированной части и сравнивается последовательно со всеми элементами отсортированной части, начиная с её конца
        5) как только в отсортированной части находится место куда должен вставиться выбранный элемент (из неотсортированной части)
        6) все элементы их отсортированной части сдвигаются вправо на 1 место и выбранный элемент встаёт на своё найденное место, длинна отсортированной части увеличивается на 1 элемент

    for (int i = 0; i < SIZE - 1; i++)
    {

        // если элемент меньше левого, то меняем местами
        for (int j = i + 1; j>0 && a[j]<a[j-1];j--)
        {
            swap(a[j], a[j-1]);
        }   
    }

Многомерные массивы
        
    Это массив массивов каждый их которых управляется своей переменной
    Для доступа к элементу:
        int matrix[i][j];

    Инициализация многомерного массива возможна следующим образом:
        int matrix[][3] {{1,2,3}, {4,5,6}, {7,8,9}};
    int a[ROW][COL];
    for (int i = 0; i < ROW; i++)
    {
        for (int j = 0; j < COL; j++)
        {
            a[i][j] = rand()%10;
        }
    }
    for (int i = 0; i < ROW; i++)
    {
        for (int j = 0; j < COL; j++)
        {
            cout << a[i][j] << ' ';
            }
        cout << endl;
    }
    cout << endl;

Задача 1:
Составить таблицу умножения
for (int i = 0; i < ROW; i++)
{
    for (int j = 0; j < COL; j++)
    {
        a[i][j] = (i+1)*(j+1);
    }
}
Задача 2:
Найти максимальный элемент матрицы, его индексы и кол-во

int max = a[0][0], index_i, index_j, count;
    for (int i = 0; i < ROW; i++)
    {
        for (int j = 0; j < COL; j++)
        {
            if (a[i][j] > max)
            {
                max = a[i][j];
                index_i = i;
                index_j = j;
                count = 1;
            }
            else if (a[i][j] == max)
            {
                count++;
            }
            cout << a[i][j] << '\t';
        }
        cout << endl;
    }
    cout << endl;
    cout << "max: " << max << '\n' << "count:" << count << '\n' << "index_i: " << index_i << '\n' << "index_j: " << index_j << endl;


Практика 2
    
Рекурсия   
    Рекурсия - процесс повторения действий внутри этого элемента

    Рекурсивный алгоритм:
        1) одного или нескольких условий выхода из тела рекурсивной функции - базиса рекурсии
        2) шага рекурсии, который в конечном счёте должен приводить к выходу из рекурсии

    Простая рекурсия
        нахождение НОД двух чисел
            1) вводится 2 числа
            2) из большего вычитается меньшее
            3) снова выбирается большее
            4) цикл выполняется до тех пор пока 2 числа не станут равными

    Сложная рекурсия - это процесс в котором одна функия вызывает вторую, а та в свою очередь вызывает первую, первая функция должна вызывать ещё не описанную вторую функцию, для этого необходима сигнатура функции.

    Сигнатура функции - часть общего объявления функции, для компилятора и определения существования этой функции

    Структура сигнатуры:
        тип имя функции (тип переменные);
        Способ передачи параметров , по значению или по ссылке

    Дано - функции f, g - чему равно f(4) по формуле f(n) = f(n-1) + g(n-2)
    g(n) = g(n-1) + f(n-2) 
    при n>2
    иначе 1

    Хвостовая рекурсия

        Префиксная форма - сперва рекурсивный вызов, потом действия
        Пример - дано n, вывести числа от нуля до n
