Практика информатика

Статические массивы

Массив - это последовательность элементов одного типа, которые:
    1) имеют одно имя
    2) имеют один тип данных
    3) пронумерованы по индексам (с нуля)
    А так же имеют номера (с единицы)

    Если кол-во элементов в массиве n (от 1 до n), то кол-во индексов тоже n (0, n-1)

int m[] {1,2,3,4,5}; - 5 элементов, значит занимает 5*4 байта = 20 байт
Резервирование памяти и её инициализация
int a[10];
for (int i = 0; i < 10; i++)
{
    cin >> a[i];
}

int m[10] {1,2,3,4,5} // остальные 5 элементов будут заполнены нулями {1,2,3,4,5,0,0,0,0,0}

функция sizeof(m); позволяет узнать объём памяти

Инициализация при помощи датчика случайных чисел

rand() - от 0 до 32767

a[i] = rand() % (2*n+1) - n диапазон (-n; n) включительно
позволяет выбрать диапазон чисел

для того чтобы каждый раз генерировались разные числа:
#include <time.h>
srand(time(NULL));

Тут должна быть блоксхема для нахождения макс элемента и его кол-ва и номера первого, за 1 проход в диапазоне от -100 до 99

Дано: 1 мерный массив целых чисел, проверить возрастает ли он?

int main()
{
    const int N = 10;
    int now;
    bool flag = true;
    int arr[N];
    for (int i = 0; i < N && flag; i++)
    {
        if (i == 0)
        {
            now = a[i]
        }
        if (now >= a[i])
        {
            flag = false;
            cout << false << endl;
        }
        else
        {
            now = a[i];
        }
    }
    if (flag)
    {
        cout << true << endl;
    }
}

Сделать лабу по этой задаче!!!
лабу в папку семместр 2 лаба 1


Анализ задачи:
1) Если бы мы шли по номерам, формула симм. элементов a = n-i+1


Лаба 2
Дано: одномерный массив целых чисел, перевернуть часть массива от элемента с индексом p до q, они симметричны
[1,2,3,4,5,6]
p = 1
q = 5
получим [1,5,4,3,2,6]
меняем от p до q

Лаба 3
Дано: одномерный массив целых чисел элементы циклически сдвинуть влево k раз
Анализ задачи:
    цилкы вложенные 
    внешний по k
    внутренний 

Лаба 4
в зелёной 
вариант 25



Дано одномерный массив целых чисел
    перед каждым чётным элементом поставить -1

Лекция 1
Методы сортировки массивов

    Метод сортировки - метод который изменяет порядок следования элементов в структуре данных

    Служат для:
        Обеспечения поиска
        Сравнения
        Обработки
        Увеличивают производительность и эффективность

    Метод обмена (пузырька)

    3 1 9 2 5

    необходимо совершить n-1 просмотра от первого до последнего

    for (int i = 0; i < size; i++)
    {
        for (int j = i; j < size - i; j++)
        {
            if (a[j] > a[j+1])
            {
                swap(a[j], a[j+1]);
            }
        }
    }

    1) просматриваем 2 соседних элемента массива двигаясь от его начала к концу
    2) Если левый больше правого, меняем местами
    3) В результате наибольший элемент окажется на n месте в массиве
    4) Так как на последнем месте максимальный элемент массива, он исключается из обработки
    5) выполняем такой просмотр n-1 раз, смотрим пары соседних элемнтов, начиная с первого до последнего элемента с номером, равному n-k, где k номер шага, в итоге получаем отсортированный массив


Метод выбора
    Алгоритм
        1) Находим в массиве минимальный элемент и меняем его местами с первым
        2) первый элемент исключаем из обработки
        3) находим минимальный элемент среди элементов с номером от 1 до n и меняем его со вторым элементом массива
        4) Продолжаем повторять поиск минимального элемента и его обмен с элементами  3-го по n-1

        int min;
        for (int i = 0; i < SIZE; i++)
        {
            min = i;

            // ищем минимальный элемент в массиве
            for (int j = i; j < SIZE; j++)
            {
                if (a[j] < a[min])
                {
                    min = j;
                }
            }

            // меняем i-ый элемент местами с минимальным
            swap(a[i], a[min]);
        }

Метод вставки

    Алгоритм
        1) массив делится на 2 части, первая часть отсортированная вторая часть не отсортированная
        2) элементы из не отсортированной части должны вставляться в отсортированную на то место, когда не нарушается порядок слеедования в отсортированной части (по убыванию или по возрастанию)
        3) на первом шаге в отсортированную часть входит только первый элемент массива
        4) берётся первый элемент из не отсортированной части и сравнивается последовательно со всеми элементами отсортированной части, начиная с её конца
        5) как только в отсортированной части находится место куда должен вставиться выбранный элемент (из неотсортированной части)
        6) все элементы их отсортированной части сдвигаются вправо на 1 место и выбранный элемент встаёт на своё найденное место, длинна отсортированной части увеличивается на 1 элемент

    for (int i = 0; i < SIZE - 1; i++)
    {

        // если элемент меньше левого, то меняем местами
        for (int j = i + 1; j>0 && a[j]<a[j-1];j--)
        {
            swap(a[j], a[j-1]);
        }   
    }

Многомерные массивы
        
    Это массив массивов каждый их которых управляется своей переменной
    Для доступа к элементу:
        int matrix[i][j];

    Инициализация многомерного массива возможна следующим образом:
        int matrix[][3] {{1,2,3}, {4,5,6}, {7,8,9}};
    int a[ROW][COL];
    for (int i = 0; i < ROW; i++)
    {
        for (int j = 0; j < COL; j++)
        {
            a[i][j] = rand()%10;
        }
    }
    for (int i = 0; i < ROW; i++)
    {
        for (int j = 0; j < COL; j++)
        {
            cout << a[i][j] << ' ';
            }
        cout << endl;
    }
    cout << endl;

Задача 1:
Составить таблицу умножения
for (int i = 0; i < ROW; i++)
{
    for (int j = 0; j < COL; j++)
    {
        a[i][j] = (i+1)*(j+1);
    }
}
Задача 2:
Найти максимальный элемент матрицы, его индексы и кол-во

int max = a[0][0], index_i, index_j, count;
    for (int i = 0; i < ROW; i++)
    {
        for (int j = 0; j < COL; j++)
        {
            if (a[i][j] > max)
            {
                max = a[i][j];
                index_i = i;
                index_j = j;
                count = 1;
            }
            else if (a[i][j] == max)
            {
                count++;
            }
            cout << a[i][j] << '\t';
        }
        cout << endl;
    }
    cout << endl;
    cout << "max: " << max << '\n' << "count:" << count << '\n' << "index_i: " << index_i << '\n' << "index_j: " << index_j << endl;


Практика 2
    
Рекурсия   
    Рекурсия - процесс повторения действий внутри этого элемента

    Рекурсивный алгоритм:
        1) одного или нескольких условий выхода из тела рекурсивной функции - базиса рекурсии
        2) шага рекурсии, который в конечном счёте должен приводить к выходу из рекурсии

    Простая рекурсия
        нахождение НОД двух чисел
            1) вводится 2 числа
            2) из большего вычитается меньшее
            3) снова выбирается большее
            4) цикл выполняется до тех пор пока 2 числа не станут равными

    Сложная рекурсия - это процесс в котором одна функия вызывает вторую, а та в свою очередь вызывает первую, первая функция должна вызывать ещё не описанную вторую функцию, для этого необходима сигнатура функции.

    Сигнатура функции - часть общего объявления функции, для компилятора и определения существования этой функции

    Структура сигнатуры:
        тип имя функции (тип переменные);
        Способ передачи параметров , по значению или по ссылке

    Дано - функции f, g - чему равно f(4) по формуле f(n) = f(n-1) + g(n-2)
    g(n) = g(n-1) + f(n-2) 
    при n>2
    иначе 1

    Хвостовая рекурсия

        Префиксная форма - сперва рекурсивный вызов, потом действия
        Пример - дано n, вывести числа от нуля до n

        Постфиксная - сперва действие, потом рекурсивный вызов

    Итерирование в рекурсиях

    Итерация - многократное поторение 

    + - рекурсии
        + программа коротка
        - переполнение стека

    Выполнить лабу без номера - рекурсии, вариант 25 (числа фибоначчи, ханойская башня, о восьми ферзях)

Числа фибоначчи - простая рекурсия

    ханойские
        3 стержня, на первом собраны все кольца по убванию диаметра к верху, необходимо, используя все 3 стержня перенести пирамидку на третий стрежень в том же поядке, можно ложить диск меньшего диаметра на диск большего, число ходов - наименьшее, перекладывать только по 1 диску
        1) перекладывание n-1 дисков на разрешённые стержни, свободный или на котором находится диск большего диаметра чем перекладываемый
        2) ищем место для освобождённого n-ого диска
        

Лекция 2
    
    Функции в c++
        Функции - блоки кода выполняющие определённые операции

        Возвращаемы_тип имя_функции (параметры)
        {
            тело_функции;
        }

ДЗ : разобраться с возможностью доступа к памяти в конкретной задаче
Прототип функции, что такое прототип функции, написать в коде, и что такое шаблон функции

        Прототип функции - только объявление функции перед main, а тело после main

        Тело функции можеть быть в другом файле

        тип имя(парметры); // прототип

        Правила работы с функциями

            1) тип данных выхода не может быть массивом или функцией
            2) тип функции зависит от типа выходных данных
            3) имя функции не может быть ключевым словом 
            4) нельзя определять функцию внутри другой функции

        Тип void в функциях

            void используется когда функция ничего не возвращает, отсутствует return;

            неправильное использование void:

                void func(int a, int b)
                {
                    return a+b;
                }

        Функция main()

            1) Точка начала выполнения программы
            2) стандарт типа функции main - int
            3) другие использования: void main(), int main(void)
            4) отсутствие return, если функция должна вернуть значенме - ошибка

        Параметры функций

            1) функции бывают вызвываемыми и вызывающими
                - вызывающая - main
                - вызываемая sum
                обмен параметрами между ними это главный маханизм работы функций

            2) виды параметров
                - формальные (в заголовке описания функции при объявлении)
                - фактические (аргуметны, в операторе вызова функии, функция буедт работать именно с ними)

            3) Способы передачи параметров в функию
                - по значению (функция работает с копиями аргументов, которые не могут изменить их исходные значения в main)
                    void f(int a, int b)
                    {
                        int c = a;
                        a = b;
                        b = c;
                    }
                - по адресу, по указателю (работа с копиями адресов аргументов, если изменить такую переменную, то она изменится в main)
                    void f(int* a, int* b)
                    {
                        int c = *a;
                        *a = *b;
                        *b = c;
                    }

        Использование классов памяти в функциях
                auto
                    - auto (для локальных переменных, по умолчанию int)
                    - для обозначение типов данных выхода и входа
                register
                    - для локальных перемменных
                    - записывает переменные в регистры процессора
                    - если места в регистрах нет - используется auto
                    inf f(int a, int b)
                    {
                        register int c;
                        c = a - b;
                        return c;
                    }
                    // пример работы с памятью

                static
                    - используется для объявления глобальных переменных внутри блока

                    void f()
                    {
                        static res = 1;
                        res++;
                        cout << res << endl;
                    }
                    если вызвать функцию 3 раза, то выведится: 2, 3, 4

                extern 
                    - для глобальных переменых для всей программы

                    extern int a = 1;

                    void f()
                    {
                        a++;
                    }
                    если вызвать функцию, то а увеличется на 1

        Передача массиваа в функцию
            В функцию передаётся указатель на первый элемент массива и кол-во элементов

            void func(int* arr, int SIZE)
            {
                ...;
            }

        Функции с переменным кол-вом параметров

            используется при неизвестном кол-ве параметров

            при описании функции явно должен быть указан хотя бы 1 параметр
            Как определить окончание, кол-во входных параметров
                1) задать в явном виде
                2) задать в виде признака окончания

                int summ(int m, ...) // m - явный параметр, обозначающий кол-во элементов
                {
                    int* p = &m + 1; // адрес следующего параметра
                    int sum = 0;
                    for (m; m != 0; m--)
                    {
                        sum += *p;
                        p++; // переход на следующий элемент параметров
                    }
                    return sum;
                }

                int summ(int m, ...) // пока один из параметров не стнет нулю, m - элемент последовательности
                {
                    int* p = &m;
                    int sum = 0;
                    while (*p)
                    {
                        sum += *p;
                        p++;
                    }
                    return sum;
                }
Д/З
лаба
7.1 - ф-ции с переменным числом параметров
7.2 - перегрузка // особое внимание на анализ задачи

        Перегрузка функций
            одна функция работает с разными типами данных

            Свойства
                1) перегруженные функции должны находиться в одной области видимости
                2) тип входных и выходных параметров отличается

        Шаблоны функций
            шаблоны вводятся для автоматизации создания перегруженных функций.
            С помощью шаблона перегруженная функция определяется один раз.

            template <typename параметр>
            переметр имя_функции(параметр входные_данные)
            {
                func_body;
            }

            cout << func<double>(a,b);


Пркатика
    Задача о 8 ферзях

        1) 1 ферзь должен стоять в каждой строке
        2) ни один ферзь не может бить любого другого
        3) реализовать алгоритм через рекурсивную функцию

        1) ставим в первую доступную, переход на след строку, снова в перую возможную
        2) так до конца, если не 8 ферзей, на строчку назад и ставим в другой возможной вариант, если его нет, то ещё на след клетку и так далее

Лекция
    Диаграммы функционального моделирования (SADT)
        Способ описания объекта (системы), которая позволяет выделить блоки активностей (отвечают за этапы работы системы) и СВЯЗИ (дуги), которые связывают блоки АКТИВНОСТЕЙ
        Результат:
            получение модели системы, для выстраивания алгоритма управления

        SADT - методология структурного анализа и проектирования (Steuctured Analysis and Design Technique)

        Этапы построения моделей системы
            1) Сбор информации с которой будеи работать
                - Опросы дял сбора фактов
                - Опросы для определения проблем
                - Совещания для принятия решений
            2) Определение цели и средства её достижения
            3) Декомпозиция и постороение диаграмм (разбивка на уровни управления)
            4) Критическая оценка, рецензирование и комментирование
            5) Признаки завершения декомпозиции - полнота модели
                - определение дополнительных возможностей для лучше детализации модели (очень абстрактная модель не читабельна, так как мало понятна)
                - отсутствие необходимости дальнейшей детализации (через изменение точки зрения понимания объекта)
                - SADT не терпит повторений, блоки не повторяются
                - блок представляет тривиальную функцию (чем более простую функцию реализует блок, тем быстрее модель превратится в код, программу)

        Правила составления диаграммы SADT
            1) состав диаграммы: блоки (Функции) и дуги (действия, связи), дуги могут изображать действия которые передаются от блока в блок
            2) Кол-во блоков ограничено: от 3 до 6-7, чтобы не путаться

        Изображение SADT моделей
            Блок, модель (ICOM: Input, Output, Control, Mechanism)
                Левая сторона: Вход (входные данные)    
                Правая сторона: Выход (результат выполнения процесса)
                Верхняя сторона: Управление (инструкции, указания, ограничения)
                Нижняя сторона: Механизмы (какие средства обеспецивают работу этого конкретного блока)
            Диаграммы располагаются в виде уровней для упрощения чтения диаграммы (Доминирование)
                Самый доминирующий блок раполагается в левом верхнем углу диаграммы

            Дуги в диаграммах IDF0
                1) взаимосвязь выход - управление между блоками
                2) выход - вход
                3) обратная связь по управлению
                4) обратная связь по входу
                5) выход - механизм

    Структуры в C++
        Структура - тип данных которых содаёт пользователь: имеет имя, структурирует разные типы переменных в одно целое
        Пример:
            Студент(Фио, группа, дата рождения)
            Метод - привязан к объекту, вызов через точку

        Объявление структуры:
            struct <name>
            {
                <field_of_structure>
            }
            struct human
            {
                int age;
                int weight; // Поля структуры
                string name; // функции -> Методы
            }
            Виды полей:
                - переменная
                - структура
                - массив
                - указатель
            Поле структуры не совпадает по типу с самой структурой, но указатель на саму структуру используется
            Обащение к структуре (->) для указателья, и (.) для переменной

            Инициализация полей

            int main()
            {
                Human Ivan;
                Ivan.age = 18;
                Ivan.name = "Ivan";
                Ivan.weight = 80;
                Ivan = {30, 80, "Ivan"};
                Human group_humans[30]; // массив этих структур
            }

            Работа с полями структуры 
            int main()
            {
                Human Ivan;
                Ivan.age = 18;
                Ivan.name = "Ivan";
                Ivan.weight = 80;
                cout << Ivan.age + Ivan.weight << endl; // Их можно сложить, а так же сравнивать

                // Ввод
                cin >> Ivan.name

                // Строку вводить лучше через getline();
                
            }
