Практика информатика

Статические массивы

Массив - это последовательность элементов одного типа, которые:
    1) имеют одно имя
    2) имеют один тип данных
    3) пронумерованы по индексам (с нуля)
    А так же имеют номера (с единицы)

    Если кол-во элементов в массиве n (от 1 до n), то кол-во индексов тоже n (0, n-1)

int m[] {1,2,3,4,5}; - 5 элементов, значит занимает 5*4 байта = 20 байт
Резервирование памяти и её инициализация
int a[10];
for (int i = 0; i < 10; i++)
{
    cin >> a[i];
}

int m[10] {1,2,3,4,5} // остальные 5 элементов будут заполнены нулями {1,2,3,4,5,0,0,0,0,0}

функция sizeof(m); позволяет узнать объём памяти

Инициализация при помощи датчика случайных чисел

rand() - от 0 до 32767

a[i] = rand() % (2*n+1) - n диапазон (-n; n) включительно
позволяет выбрать диапазон чисел

для того чтобы каждый раз генерировались разные числа:
#include <time.h>
srand(time(NULL));

Тут должна быть блоксхема для нахождения макс элемента и его кол-ва и номера первого, за 1 проход в диапазоне от -100 до 99

Дано: 1 мерный массив целых чисел, проверить возрастает ли он?

int main()
{
    const int N = 10;
    int now;
    bool flag = true;
    int arr[N];
    for (int i = 0; i < N && flag; i++)
    {
        if (i == 0)
        {
            now = a[i]
        }
        if (now >= a[i])
        {
            flag = false;
            cout << false << endl;
        }
        else
        {
            now = a[i];
        }
    }
    if (flag)
    {
        cout << true << endl;
    }
}

Сделать лабу по этой задаче!!!
лабу в папку семместр 2 лаба 1


Анализ задачи:
1) Если бы мы шли по номерам, формула симм. элементов a = n-i+1


Лаба 2
Дано: одномерный массив целых чисел, перевернуть часть массива от элемента с индексом p до q, они симметричны
[1,2,3,4,5,6]
p = 1
q = 5
получим [1,5,4,3,2,6]
меняем от p до q

Лаба 3
Дано: одномерный массив целых чисел элементы циклически сдвинуть влево k раз
Анализ задачи:
    цилкы вложенные 
    внешний по k
    внутренний 

Лаба 4
в зелёной 
вариант 25



Дано одномерный массив целых чисел
    перед каждым чётным элементом поставить -1

Лекция 1
Методы сортировки массивов

    Метод сортировки - метод который изменяет порядок следования элементов в структуре данных

    Служат для:
        Обеспечения поиска
        Сравнения
        Обработки
        Увеличивают производительность и эффективность

    Метод обмена (пузырька)

    3 1 9 2 5

    необходимо совершить n-1 просмотра от первого до последнего

    for (int i = 0; i < size; i++)
    {
        for (int j = i; j < size - i; j++)
        {
            if (a[j] > a[j+1])
            {
                swap(a[j], a[j+1]);
            }
        }
    }

    1) просматриваем 2 соседних элемента массива двигаясь от его начала к концу
    2) Если левый больше правого, меняем местами
    3) В результате наибольший элемент окажется на n месте в массиве
    4) Так как на последнем месте максимальный элемент массива, он исключается из обработки
    5) выполняем такой просмотр n-1 раз, смотрим пары соседних элемнтов, начиная с первого до последнего элемента с номером, равному n-k, где k номер шага, в итоге получаем отсортированный массив


Метод выбора
    Алгоритм
        1) Находим в массиве минимальный элемент и меняем его местами с первым
        2) первый элемент исключаем из обработки
        3) находим минимальный элемент среди элементов с номером от 1 до n и меняем его со вторым элементом массива
        4) Продолжаем повторять поиск минимального элемента и его обмен с элементами  3-го по n-1

        int min;
        for (int i = 0; i < SIZE; i++)
        {
            min = i;

            // ищем минимальный элемент в массиве
            for (int j = i; j < SIZE; j++)
            {
                if (a[j] < a[min])
                {
                    min = j;
                }
            }

            // меняем i-ый элемент местами с минимальным
            swap(a[i], a[min]);
        }

Метод вставки

    Алгоритм
        1) массив делится на 2 части, первая часть отсортированная вторая часть не отсортированная
        2) элементы из не отсортированной части должны вставляться в отсортированную на то место, когда не нарушается порядок слеедования в отсортированной части (по убыванию или по возрастанию)
        3) на первом шаге в отсортированную часть входит только первый элемент массива
        4) берётся первый элемент из не отсортированной части и сравнивается последовательно со всеми элементами отсортированной части, начиная с её конца
        5) как только в отсортированной части находится место куда должен вставиться выбранный элемент (из неотсортированной части)
        6) все элементы их отсортированной части сдвигаются вправо на 1 место и выбранный элемент встаёт на своё найденное место, длинна отсортированной части увеличивается на 1 элемент

    for (int i = 0; i < SIZE - 1; i++)
    {

        // если элемент меньше левого, то меняем местами
        for (int j = i + 1; j>0 && a[j]<a[j-1];j--)
        {
            swap(a[j], a[j-1]);
        }   
    }

Многомерные массивы
        
    Это массив массивов каждый их которых управляется своей переменной
    Для доступа к элементу:
        int matrix[i][j];

    Инициализация многомерного массива возможна следующим образом:
        int matrix[][3] {{1,2,3}, {4,5,6}, {7,8,9}};
    int a[ROW][COL];
    for (int i = 0; i < ROW; i++)
    {
        for (int j = 0; j < COL; j++)
        {
            a[i][j] = rand()%10;
        }
    }
    for (int i = 0; i < ROW; i++)
    {
        for (int j = 0; j < COL; j++)
        {
            cout << a[i][j] << ' ';
            }
        cout << endl;
    }
    cout << endl;

Задача 1:
Составить таблицу умножения
for (int i = 0; i < ROW; i++)
{
    for (int j = 0; j < COL; j++)
    {
        a[i][j] = (i+1)*(j+1);
    }
}
Задача 2:
Найти максимальный элемент матрицы, его индексы и кол-во

int max = a[0][0], index_i, index_j, count;
    for (int i = 0; i < ROW; i++)
    {
        for (int j = 0; j < COL; j++)
        {
            if (a[i][j] > max)
            {
                max = a[i][j];
                index_i = i;
                index_j = j;
                count = 1;
            }
            else if (a[i][j] == max)
            {
                count++;
            }
            cout << a[i][j] << '\t';
        }
        cout << endl;
    }
    cout << endl;
    cout << "max: " << max << '\n' << "count:" << count << '\n' << "index_i: " << index_i << '\n' << "index_j: " << index_j << endl;


Практика 2
    
Рекурсия   
    Рекурсия - процесс повторения действий внутри этого элемента

    Рекурсивный алгоритм:
        1) одного или нескольких условий выхода из тела рекурсивной функции - базиса рекурсии
        2) шага рекурсии, который в конечном счёте должен приводить к выходу из рекурсии

    Простая рекурсия
        нахождение НОД двух чисел
            1) вводится 2 числа
            2) из большего вычитается меньшее
            3) снова выбирается большее
            4) цикл выполняется до тех пор пока 2 числа не станут равными

    Сложная рекурсия - это процесс в котором одна функия вызывает вторую, а та в свою очередь вызывает первую, первая функция должна вызывать ещё не описанную вторую функцию, для этого необходима сигнатура функции.

    Сигнатура функции - часть общего объявления функции, для компилятора и определения существования этой функции

    Структура сигнатуры:
        тип имя функции (тип переменные);
        Способ передачи параметров , по значению или по ссылке

    Дано - функции f, g - чему равно f(4) по формуле f(n) = f(n-1) + g(n-2)
    g(n) = g(n-1) + f(n-2) 
    при n>2
    иначе 1

    Хвостовая рекурсия

        Префиксная форма - сперва рекурсивный вызов, потом действия
        Пример - дано n, вывести числа от нуля до n

        Постфиксная - сперва действие, потом рекурсивный вызов

    Итерирование в рекурсиях

    Итерация - многократное поторение 

    + - рекурсии
        + программа коротка
        - переполнение стека

    Выполнить лабу без номера - рекурсии, вариант 25 (числа фибоначчи, ханойская башня, о восьми ферзях)

Числа фибоначчи - простая рекурсия

    ханойские
        3 стержня, на первом собраны все кольца по убванию диаметра к верху, необходимо, используя все 3 стержня перенести пирамидку на третий стрежень в том же поядке, можно ложить диск меньшего диаметра на диск большего, число ходов - наименьшее, перекладывать только по 1 диску
        1) перекладывание n-1 дисков на разрешённые стержни, свободный или на котором находится диск большего диаметра чем перекладываемый
        2) ищем место для освобождённого n-ого диска
        

Лекция 2
    
    Функции в c++
        Функции - блоки кода выполняющие определённые операции

        Возвращаемы_тип имя_функции (параметры)
        {
            тело_функции;
        }

ДЗ : разобраться с возможностью доступа к памяти в конкретной задаче
Прототип функции, что такое прототип функции, написать в коде, и что такое шаблон функции

        Прототип функции - только объявление функции перед main, а тело после main

        Тело функции можеть быть в другом файле

        тип имя(парметры); // прототип

        Правила работы с функциями

            1) тип данных выхода не может быть массивом или функцией
            2) тип функции зависит от типа выходных данных
            3) имя функции не может быть ключевым словом 
            4) нельзя определять функцию внутри другой функции

        Тип void в функциях

            void используется когда функция ничего не возвращает, отсутствует return;

            неправильное использование void:

                void func(int a, int b)
                {
                    return a+b;
                }

        Функция main()

            1) Точка начала выполнения программы
            2) стандарт типа функции main - int
            3) другие использования: void main(), int main(void)
            4) отсутствие return, если функция должна вернуть значенме - ошибка

        Параметры функций

            1) функции бывают вызвываемыми и вызывающими
                - вызывающая - main
                - вызываемая sum
                обмен параметрами между ними это главный маханизм работы функций

            2) виды параметров
                - формальные (в заголовке описания функции при объявлении)
                - фактические (аргуметны, в операторе вызова функии, функция буедт работать именно с ними)

            3) Способы передачи параметров в функию
                - по значению (функция работает с копиями аргументов, которые не могут изменить их исходные значения в main)
                    void f(int a, int b)
                    {
                        int c = a;
                        a = b;
                        b = c;
                    }
                - по адресу, по указателю (работа с копиями адресов аргументов, если изменить такую переменную, то она изменится в main)
                    void f(int* a, int* b)
                    {
                        int c = *a;
                        *a = *b;
                        *b = c;
                    }

        Использование классов памяти в функциях
                auto
                    - auto (для локальных переменных, по умолчанию int)
                    - для обозначение типов данных выхода и входа
                register
                    - для локальных перемменных
                    - записывает переменные в регистры процессора
                    - если места в регистрах нет - используется auto
                    inf f(int a, int b)
                    {
                        register int c;
                        c = a - b;
                        return c;
                    }
                    // пример работы с памятью

                static
                    - используется для объявления глобальных переменных внутри блока

                    void f()
                    {
                        static res = 1;
                        res++;
                        cout << res << endl;
                    }
                    если вызвать функцию 3 раза, то выведится: 2, 3, 4

                extern 
                    - для глобальных переменых для всей программы

                    extern int a = 1;

                    void f()
                    {
                        a++;
                    }
                    если вызвать функцию, то а увеличется на 1

        Передача массиваа в функцию
            В функцию передаётся указатель на первый элемент массива и кол-во элементов

            void func(int* arr, int SIZE)
            {
                ...;
            }

        Функции с переменным кол-вом параметров

            используется при неизвестном кол-ве параметров

            при описании функции явно должен быть указан хотя бы 1 параметр
            Как определить окончание, кол-во входных параметров
                1) задать в явном виде
                2) задать в виде признака окончания

                int summ(int m, ...) // m - явный параметр, обозначающий кол-во элементов
                {
                    int* p = &m + 1; // адрес следующего параметра
                    int sum = 0;
                    for (m; m != 0; m--)
                    {
                        sum += *p;
                        p++; // переход на следующий элемент параметров
                    }
                    return sum;
                }

                int summ(int m, ...) // пока один из параметров не стнет нулю, m - элемент последовательности
                {
                    int* p = &m;
                    int sum = 0;
                    while (*p)
                    {
                        sum += *p;
                        p++;
                    }
                    return sum;
                }
Д/З
лаба
7.1 - ф-ции с переменным числом параметров
7.2 - перегрузка // особое внимание на анализ задачи

        Перегрузка функций
            одна функция работает с разными типами данных

            Свойства
                1) перегруженные функции должны находиться в одной области видимости
                2) тип входных и выходных параметров отличается

        Шаблоны функций
            шаблоны вводятся для автоматизации создания перегруженных функций.
            С помощью шаблона перегруженная функция определяется один раз.

            template <typename параметр>
            переметр имя_функции(параметр входные_данные)
            {
                func_body;
            }

            cout << func<double>(a,b);


Пркатика
    Задача о 8 ферзях

        1) 1 ферзь должен стоять в каждой строке
        2) ни один ферзь не может бить любого другого
        3) реализовать алгоритм через рекурсивную функцию

        1) ставим в первую доступную, переход на след строку, снова в перую возможную
        2) так до конца, если не 8 ферзей, на строчку назад и ставим в другой возможной вариант, если его нет, то ещё на след клетку и так далее

Лекция
    Диаграммы функционального моделирования (SADT)
        Способ описания объекта (системы), которая позволяет выделить блоки активностей (отвечают за этапы работы системы) и СВЯЗИ (дуги), которые связывают блоки АКТИВНОСТЕЙ
        Результат:
            получение модели системы, для выстраивания алгоритма управления

        SADT - методология структурного анализа и проектирования (Steuctured Analysis and Design Technique)

        Этапы построения моделей системы
            1) Сбор информации с которой будеи работать
                - Опросы дял сбора фактов
                - Опросы для определения проблем
                - Совещания для принятия решений
            2) Определение цели и средства её достижения
            3) Декомпозиция и постороение диаграмм (разбивка на уровни управления)
            4) Критическая оценка, рецензирование и комментирование
            5) Признаки завершения декомпозиции - полнота модели
                - определение дополнительных возможностей для лучше детализации модели (очень абстрактная модель не читабельна, так как мало понятна)
                - отсутствие необходимости дальнейшей детализации (через изменение точки зрения понимания объекта)
                - SADT не терпит повторений, блоки не повторяются
                - блок представляет тривиальную функцию (чем более простую функцию реализует блок, тем быстрее модель превратится в код, программу)

        Правила составления диаграммы SADT
            1) состав диаграммы: блоки (Функции) и дуги (действия, связи), дуги могут изображать действия которые передаются от блока в блок
            2) Кол-во блоков ограничено: от 3 до 6-7, чтобы не путаться

        Изображение SADT моделей
            Блок, модель (ICOM: Input, Output, Control, Mechanism)
                Левая сторона: Вход (входные данные)    
                Правая сторона: Выход (результат выполнения процесса)
                Верхняя сторона: Управление (инструкции, указания, ограничения)
                Нижняя сторона: Механизмы (какие средства обеспецивают работу этого конкретного блока)
            Диаграммы располагаются в виде уровней для упрощения чтения диаграммы (Доминирование)
                Самый доминирующий блок раполагается в левом верхнем углу диаграммы

            Дуги в диаграммах IDF0
                1) взаимосвязь выход - управление между блоками
                2) выход - вход
                3) обратная связь по управлению
                4) обратная связь по входу
                5) выход - механизм

    Структуры в C++
        Структура - тип данных которых содаёт пользователь: имеет имя, структурирует разные типы переменных в одно целое
        Пример:
            Студент(Фио, группа, дата рождения)
            Метод - привязан к объекту, вызов через точку

        Объявление структуры:
            struct <name>
            {
                <field_of_structure>
            }
            struct human
            {
                int age;
                int weight; // Поля структуры
                string name; // функции -> Методы
            }
            Виды полей:
                - переменная
                - структура
                - массив
                - указатель
            Поле структуры не совпадает по типу с самой структурой, но указатель на саму структуру используется
            Обащение к структуре (->) для указателья, и (.) для переменной

            Инициализация полей

            int main()
            {
                Human Ivan;
                Ivan.age = 18;
                Ivan.name = "Ivan";
                Ivan.weight = 80;
                Ivan = {30, 80, "Ivan"};
                Human group_humans[30]; // массив этих структур
            }

            Работа с полями структуры 
            int main()
            {
                Human Ivan;
                Ivan.age = 18;
                Ivan.name = "Ivan";
                Ivan.weight = 80;
                cout << Ivan.age + Ivan.weight << endl; // Их можно сложить, а так же сравнивать

                // Ввод
                cin >> Ivan.name

                // Строку вводить лучше через getline();
                
            }

            Для создания экземпляра вложенной структуры используется ::
            struct galaxy
            {
                struct planet
                {
                    Характеристики
                }
            }
            galaxy::planet a;
            В структуре в которой находится вложенная структура, могут находится объекты этого поля
            
Указатели и динамические массивы
    Указатели в С++
        указатель - переменная которая хранит адрес ячейки памяти
        Тип привязан к переменной по адресу

        Указатель может быть константой или переменной.
        Указатель указывает на константу или переменную

        int n;
        const int m = 1;

        int* pn;
        const int* pn;
        int* const pn = &n;  // не изменить указатель, указатель - константа
        const int* const pm = &m; // указатель константа, на целую константу, нельзя из менить ни указатель, ни значение

        Виды указателей:
            Указатель на объект
                int* p; // тип не ссыка и не битовое поле
                    Битовое поле
                        Это поле некоторой структуры, содержит некоторое число битов
                        + экономия памяти
                    struct DateTime
                    {
                        unsigned short day: 5; // кол-во бит
                        unsigned short month: 4;
                        unsigned short year: 7;
                    }

            Ссылка
                Разыменованный указатель

            Указатель на функцию
                Это адрес по которомму передаётся упавление при вызове функции в коде программы
                    1) вызов через обращение к переменной которая хранит адрес функии
                    2) чтобы передать имя функции в другую функцию как параметр

                    int (*func)(double, int, ...);
                    тип имя_указателя типы_параметорв
                    имя_указателя = имя_функции // хранит вызов функции

            Указатель на void
                Когда сразу трудно определить, какой тип данных объекта будет хравниться в ячейке

                1) можно присваивать значение указателя любого типа
                2) можно сравнивать с любыми указателями
                3) Перед использованием void преобразуется к конкретному типу через static_cast

                int a = 7;

                void* p = &a; // указатель типа void не разыменовывается

                int* p = static_cast<int*> (p);

        Инициализация указателей
            1) с помощью разадресации
                int a = 5;
                int* pa = &a;

            2) с помощью другого указателя
                int* pa = &a;
                int* pb = pa;

            3) с помощью имени массива или функции, которые трактуются как адрес
                int arr[10];

                int* t = mas;
                void f(int a)
                {
                    ...
                }
                void (*pf)(int);
                pf = f;

            4) присваивание указателю адреса области памяти в явном виде
                char* p = (char*)0xB8000000;

            5) присвоение пустого значения
                int* s = NULL;
                int* s = 0;
                int* s = nullptr;


            6) Выделение участка динамической памяти и присваивание её адреса

                1) с помощью оператора new
                    int* n = new int;
                    int* m = new int(10);
                    int* q = new int[10];

                2) #include <malloc.h>
                    int* u = (int*)malloc(sizeof(int));

    Составные типы данных
        int* (*p[10])(); - массив из 10 указателей на функции которые не имеют параметров, и возвращают значение int
        1) чтение изнутри наружу
        2) квадратные и круглые скобки имеют одинаковый приоритет
        3) последним рассматривается спецификатор типа

        char* p;
        int* n;
        double* m;
        p++; // увелитися на 1 (так как 1 байт)
        n++; // уведитится на 4
        m++; // увеличится на 8

    Динамические массивы

        int size = 100;

        float* arr =  new float[size]; 100 значений флоат

        память освобождается delete [] arr;
        если malloc, то free(arr);

        освобождать необходимо обязательно, иначе утечка памяти

    Перечислимый тип данных
        Это значения символьных констант
        1) не требует выделения памяти
        2) память выделяется когда переменная этого типа определена

        enum Colors
        {
            RED,
            WHITE,
            BLACK,
            BLUE,
        };

        Имена в разных перечислителях enum не повторяется

        В перечислителях можно создавать их классы

        enum class A
        {
            A,
            B,
        };

        enum class B
        {
            A,
            B,
        };

        Каждому перечислителю присваивается значение
        enum Colors
        {
            COLOR_RED, // 0
            COLOR_WHITE, // 1
            COLOR_BLACK, // 2
            COLOR_BLUE, // 3
        };

        enum Animals
        {
            ANIMAL_PIG = -4,
            ANIMAL_WOLF, // -3
            ANIMAL_CAT = 6,
            ANIMAL_DOG = 6,
            ANIMAL_HORSE, // 7
        };

        если не определено, то оно будет иметь значение на 1 больше предыдущего
        Если 2 определителя получили одинаковое значение в одном enum, то это делать не рекомендуется 


        Обработка enum
            1) т.к. значения - целые числа, то их можно выводить в консоль, и присваивать int
            2) компилятор не конверитрует самостоятельно значения перечислителей
            3) нельзя ввести перечислитель через cin
            4) присвоение значения перечислителя из одного enum перечислителю из другого делать нельзя

        Приведение типов данных
            Это процесс изменения типа данных объекта
            бывает явным и неявным:
                Неявное:
                    int a = 6;
                    double b = a;

                    char a = 'n';
                    int b = a; // в ASCII
                Явное:
                    double a = 132.6893;
                    int b = (int)a; // 133

        Освобождение динамической памяти
            int* arr = new arr[50];
            delete [] arr;

            Удаление необходимо осуществлять в области видимости
            for (int i = 0; i < 5; i++)
            {
                int* a = new int;
                *a = 10 + i;
                cout << *a << endl;
            }
            delete a; // ошибка

            Если указателю присвоить значение другого указателя, при этом не освободив динамическую память, произойдёт утечка

            int* a = new int;
            *a = 10;
            int b = 20;
            cout << *a << endl;
            a = &b;
            cout << *a << endl;
            delete a; // удалится не то что нужно, нужно поставить перед присвоением a другого адреса

        Многомерные динамические массивы
            это массив указателей на массивы
            int* a[count_row] - каждая строка - массив
            int a[count_row][count_col]

            Создание:
                1)
                    int row = 5;
                    int** arr = (int**) new int[row][10] // это %№?%*
                2)
                    cin >> row >> col;
                    int** a = new int* [row]; // nice
                    for (int i = 0; i < row; i++)
                    {
                        a[i] = new int[col]
                    }
                    for (int i = 0; i < row; i++)
                    {
                        delete [] a[i];
                    }
                    delete [] a;
Лекция
    Динамические структуры данных. Одно и двунаправленные списки
        Динамическая структура - это объект который работает с динамической памятью
        Обычно динамическая память выделяется сегменатми(блоками)
        Блок(node) - это поля и сввязи между ними
        Для описания node и создаётся динамическая структура через систему указателей
        Если node не ссылается на другие, то указателю на него присвается значение nullptr

        Списки
            Однонаправленные
                node (данные, указатель) указывает не блок следующего узла
                1) работа с node организована через список
                2) если есть классификация в коде, то список этой классификации имеет поле с указателем на начальный узел
                3) возможно создать указатель на любой нужный для заадчи узел

                экземпляр списка -> указатель на головной узел -> головной узел -> узел -> узел -> последний узел хранит нулевой указатель 
                (Стрелочка -> - указатель на следующий нод)

                struct Node 
                {
                    int data;
                    Node* pointer_to_next_node = nullptr;
                };

                struct List
                {
                    Node* head_node = nullptr;
                };

                // Добавление элементов в конец списка

                void pushBack(List& list, const int& data)
                {
                    Node* new_node = new Node; // динамически создаём новый узел
                    new_node -> data = data; // Присваиваем полю узла data данные

                    if (list.head_node == nullptr) // если список пуст
                    {
                        // новый узел становится головным узлом списка
                        list.head_node = new_node;
                    }
                    else
                    {
                        // берём в качестве текущего узла начальный
                        Node* current_node = list.head_node;

                        // пока не найдём последний узел в списке
                        while (current_node->pointer_to_next_node != nullptr)
                        {
                            // переходим к следующему узлу
                            current_node = current_node->pointer_to_next_node;
                        }
                        current_node->pointer_to_next_node = new_node;
                    }
                }

                ---------------------
                ...
                struct List
                {
                    Node* head_node = nullptr;
                    Node* tail_node = nullptr;
                };

                // Добавление элементов в конец списка

                void pushBack(List& list, const int& data)
                {
                    Node* new_node = new Node; // динамически создаём новый узел
                    new_node -> data = data; // Присваиваем полю узла data данные

                    if (list.head_node == nullptr) // если список пуст
                    {
                        list.head_node = new_node;
                        list.tail_node = new_node;
                    }
                    else
                    {
                        list.tail_node->pointer_to_next_node = new_node;
                        list.tail_node = new_node
                    }
                }

                // добавление и вывод
                int main()
                {
                    List list;

                    for (int i = 0; i != 7; i++)
                    {
                        pushBack(list, i*i);
                    }
                    Node* current_node = list.head_node;
                    while (current_node != nullptr)
                    {
                        cout << current_node->data << ' ';
                        current_node = current_node->pointer_to_next_node;
                    }
                }
                ------------------------------------------
                // удаление из списка
                void popFront(List& list)
                {
                    if (list.head_node == nullptr)
                    {
                        return;
                    }
                    Node* remove = list.head_node;

                    list.head_node = list.head_node->pointer_to_next_node;

                    if (remove == list.tail_node)
                    {
                        list.tail_node = nullptr;
                    }

                    delete remove;
                }

            Двусвязные списки
                указатель на главный узел -> головной узел <-> узел <-> узел <-> хвостовой узел <- указатель на хвостовой узел

                struct Node
                {
                    int data;
                    Node* pointer_to_preview_node = nullptr;
                    Node* pointer_to_next_node = nullptr;

                };

                struct List
                {
                    Node* head_node = nullptr;
                    Node* tail_node = nullptr;
                }; 

                //вставка элемента на индекс 
                void insertItem(List& list, const int& data, const int& index = 0)
                {
                    Node* new_node = new Node;
                    new_node->data = data;

                    if (list.head_node == nullptr)
                    {
                        list.head_node = new_node;
                        list.tail_node = new_node;
                        return;
                    }

                    int counter = 0;
                    Node* current_node = list.head_node;
                    while (counter != index)
                    {
                        current_node = current_node->pointer_to_next_node;
                        counter++;
                    }

                    new_node->pointer_to_preview_node = current_node;
                    if (current_node->pointer_to_next_node != nullptr)
                    {
                        new_node->pointer_to_next_node = current_node->pointer_to_next_node;
                        current_node->pointer_to_next_node->pointer_to_preview_node = new_node;
                    }
                    current_node->pointer_to_next_node = new_node;
                    list.tail_node = new_node;

                }
        Стеки
            Стек - это линейная структура данных, когда добавление и удаление элементов идёт с вершиный стека

            Как стопка тарелок, добавить и убрать можно только сверху
            Принцип LIFO (last in first out)

            Стек, как односвязный список
            Единицей стека является узел
            Элемент стека - это узел, который содержит: данные, указатель на следующий узел, собственный адрес с помощью которого элементы связаны друг с другом

            Первый, верхний элемент - head
            Размер стека - size, кол-во элементов в стеке

            nullptr - признак окончания

            Объявление стека

            template <class T>
            struct Node
            {
                T data;
                Node<T>* next_ptr;
            };

            template <class T>
            struct Stack
            {
                Node<T>* head;
                int size;
            };

            template <class T>
            void SetNode(Node<T>*& node, T data = T(), Node<T>* next_ptr = nullptr)
            {
                node = new Node<T>();
                node->next_ptr = next_ptr;
                node->data = data;
            }

            template <class T>
            void SetStack(Stack<T>& tmp)
            {
                tmp.head = nullptr;
                tmp.size = 0;
            }

            template <class T>
            void Push(Stack<T>& tmp, const T& data)
            {
                Node<T>* new_node;
                SetNode(new_node, data, tmp.head); // tmp.head текущаю вершина стека

                // меняем указатель на новую голову стека, новый узел - голова
                tmp.head = new_node;
                tmp.size++;
            }

            template <class T>
            void Pop(Stack<T>& tmp)
            {
                if (tmp.head == nullptr)
                {
                    Node<T>* delete_element = tmp.head;

                    tmp.head = tmp.head -> next_ptr;

                    delete delete_element;

                    tmp.size--;
                }
            }

        Очереди
            Работает по принципу (first in first out FIFO)

            Добавление в конец, а выход из начала

            Структура очереди - узел очереди 
                1) Данные
                2) указатель на следующий элемент очереди 

            Последний элемент указывает на nullptr

            template <class T>
            struct Node
            {
                T data;
                Node<T>* next;
            };

            template <class T>
            struct Queue
            {
                int size;
                Node<T>* head;
                Node<T>* tail;
            };

            template <class T>
            void init_queue(Queue<T>& q, const T& value)
            {
                Node<T>* new_node = new Node<T>();
                new_node->data = value;
                q.head = new_node;
                q.tail = new_node;
                q.size = 1;
            }

            template <class T>
            void push(Queue<T>& q, const T& value)
            {
                Node<T>* = new Node<T>();
                q.size++;
                new_node->data = value;
                new_node->next = nullptr;
                q.tail->next = new_node;
                q.tail = new_node;
            }

            template <class T>
            void new_queue(Queue<T>& q, int n)
            {
                T a;
                cout << "Введите элемент: ";
                cin >> a;
                init_queue(q, a);
                for (int i = 2; i <= n; i++)
                {
                    cout << "Введите элемент: ";
                    cin >> a;
                    push(q, a);
                }
            }

            template <class T>
            void delete_queue(Queue<T>& q)
            {
                while (q.head->next != nullptr)
                {
                    pop(q); // своя функция
                }
                Node<T>& tmp = q.head;
                q.head = nullptr;
                q.size--;
                delete tmp;
            }


Практика 

    Сортировки

        Сортировка слиянием 
            В алгоритме происходит декомпозиция задачи на несколько мелких, которые решаются просто

            Сортировка слиянием декомпозирует массив до тех пор пока каждый участок не будет состоять только из 1 элемента, которые легко расставить по критерию сортировки


            Алгоритм сортировки слиянием
                1) необходимо 2 функции: разделение массива на группы, слияние в требуемом порядке
                2) особеноости: в методе слияния декомпозиция и сортировка будут идти независимо от того, отсортирован исходный массив или нет
                3) необходима дополнительная память

        Быстрая сортировка
            Выбирается ключевой элемент который делит исходный массив на 2 части

            Перемещаем все элементы меньше ключевого влево, а больше вправо

            Повторяем выбор ключевых элементов для левой и правой части пока ключевым не останется 1 элемент

        Сортировка подсчётом 
            Метод работает если: 
                сортируются целые числа
                кол-во их разнообразия не высокая, например числа от 0 до 1000
                много повторяющихся элементов
                небольшой диапазон разброса элементов

            Алгоритм:  
                1) находим максимальным и минимальный элемент
                2) считаем кол-во элементов у каждого ключа (становится известна длина массива)

        Блочная сортировка
            Разделям массив на несколько блоков по числовому диапазону после того как отсортировали блоки сливаем их в один массив


        Метод Шелла
            1) находи центральный элемент (pivot)
            индекс центрального элемента - шаг (step)
            2) Определяем блоки элементов (длина блока - step)
            3) создаём блоки из 2 элементов отстающих друг от друга на step
            4) попарно сравниваем элементы и меняем их местами
            5) новый step = step / 2

        Сортировка Хоара
            1) опорный элемент - центр массива
            2) устанавливаем левый и правый индекс массива (левый = 0, правый = size-1)

            Основа алгоритма, в левую часть от опорного перемещаются все элементы менбше него а в правую часть все элементы больше него

            Сравниваем элемент под left с middle, если left меньше то left увеличиваем на 1
            если left больше, то проход слева останавливается

            Дальше начинаем идти справа, если справа попадётся меньше, то останавливаем


Лекция
    Если в функции много параметров не понятных для пользователя
    Чтобы функция выглядела корректно, нужно чтобы её параметры были ожидаемы, необходимо перегрузить функции и передать в функцию только ожидаемые параметры 

    Директива процессора #pragma once говорит компилятору о том чтобы компиляция данного файла не повторялась

    При выводе массива лучше не оставлять пробел в конце

    При сравнении двух коллекций первым делом проверяется кол-во элементов в этих двух коллекциях

    Важно уметь использовать флажкок для обеспечения выхода

    Машина состояний помогает нам управлять состоянием программы, это помогает оптимизировать прогамму, сокращает кол-во кода, уменьшает время работы, более читаемо

    typedef используется для создания переменной, который позволяет записать составной тип

    void* - казатель на функцию

    typedef может использоваться чтобы брать указатель на функцию(делегат)

    for (int i: list) по всем элементам

    шаблон - generic

    Если использованы обобщённые типы, необходимо думать об ограничении, условиях

    system("chcp 1251 > Null");


    Сортировка естественным слиянием
        1) разделение на возрастающие серии
        2) слияние таких серий
        (41) (8 15 24) (2) (1 12) (7)
        Сливаем сравинвая каждый элемент первой серии с элементом второй
        (8 15 24 41) (2) (1 12) (7)
        (2 8 15 24 41) (1 12) (7)
        (1 2 8 12 15 24 41) (7)
        (1 2 7 8 12 15 24 41)

    Многофазная сортировка
        1) разделение исходного массива на n последовательностей (по принципу чисел фибоначи в идеале)
        если не получается по фибоначи, добавляем несколько пустых серий


    Оценка сложности алгоритмов O-большое

        оценивается в кол-ве выполняемых шагов

        кол-во операция зависит от передаваемых параметров

        2 оси (кол-во операций, объём данных)
        N!, 2^N, N*log(N), N, log(N), 1
        о умешньению кол-ва операций

        константный - время не зависит от размера входных данных

        если кол-во шагов переменная - то сложность алгоритма O(N)

        сублинейная сложность - O(sqtr(N))

        O(N+1+1) = O(N)

        Если аргументов несколько, то они учитываются O(N+K)

        При вложенных циклах - O(N*K), O(N^2) - смотря сколько вложенных циклов

        в случае O(N^2 + N) = O(N^2)

        O(3*N + N^2 + 2^N) = O(2^N)


    Методы поиска
        
        Поиск - нахождение информации в множестве данных

        Ключ поиска - поле записи по значению которого происходит поиск

        1 шаг - определение ключевого элемента
        2 шаг - сравнение элементов для осуществления поиска
        3 шаг - перебор элементов множества

        Делятся на 2 типа:
            По упорядоченном множестве данных
            Поиск в неупорядоченном

        Линейный поиск
            в неупорядоченном множестве, сравнение каждого с искомым

        Бинарный поиск
            Нахождение искомого элемента в упорядоченном множестве

        Интерполяционный поиск
            Самый быстрый способ нахождения
            mid - индекс элемента с которым сравнивается значение ключа
            key - ключ
            a[] - массив
            left, right - левый и правый индекс массива

            формула: mid = left + ((key-a[left])*(right - left)/(a[right] - a[left]))

            Плюсы: быстрый
            минус: с отсортированным множеством данных

        Прямой поиск подстроки в строке
            подстроку двигаем по строке и ищем совпадение сперва первого, а далее и последующих

            плюсы: алгоритм малозатратный
            минусы: долгое выполнение, просмотр всегда с первого символа

        Алгоритм Бойера-Мура
            Сравнение начинает с права-налево
            Используется в браузере и приложениях ctrl+f

            Для анализа совпадений используется массив который называется таблица смещений

            Свмещаем начало строки и подстроки и посимвольное сравнение начинается с последнего символа подстроки
            Если символы совпали то происходит переход к предыдущему символу подстроки, который снова сравнивается с соответствующим символом в строке, если символы не совпали сдвигаем подстроку вдоль строки на то кол-во символов, которое указано в таблице смещений

            Если все символы совпали, то выдаётся ответ о том, что поиск завершён успешно

            Формирование таблицы смещений:
                Дана подстрока: данные; д удалена на 5 символов, а на 4, н на 3 и так далее
                удалённость е - 0; справа на лево;

                таблица смещения: 5 4 2 2 1 4 6, ставим 6 в конец в слачае если символа строки нет в построке

                в таблицу смещения записываем удалённость данного символа от конца подстроки в штуках символов ы - 1 так как до конца подстроки от ы остаётся 1 элемент, н - 2 так как на 2 элемента, если встретился повторяющийся символ, то в талицу смещения записываем значения предыдущего такого-же символа, а-4, д-5; далее символы е и *, в таблицу смещения для последнего элемента записывается длина подстроки (е-6), но если он встречался ранее, то записываем прошлое значение, *-присваивается длина строки-всегда, * нужна чтобы обрабатывать символ, которого не в строке

                Если подстрока: денные
                то таблица: 5 4 2 2 1 4 6

            Поиск образа в строке
                Дана строка: пероснальные_данные
                Подстрока которую ищем: данные
                таблица смещения: 5 4 2 2 1 6 6
                1) н != е значит сдвигаем на 2 (
                персональные_данные
                  данные
                )
                2) л != е значит двигаем на 6 (
                персональные_данные
                        данные
                )
                3) д != е двигаем на 5 (
                персональные_данные
                             данные
                )
                4) посимвольно проверяем, строка совпала

                Строка: метадата
                подстрока: дата
                таблица: 3 2 1 2 4

                1) метадата
                   дата
                    a==a т==т а!=е
                    смешаемся на 2 (а)

                    (если символ в строке но не совпадает, то смещаемся на предыдущий совпавший)

                Сложность O(n+m)

        Метода Кнута-Морриса-Пратта

            1) формирование массива, содержащего значения для определения смещения образа вдоль строки на каждом шаге проверки
            2) метод использует понятия префикса и суффикса, их в каждом образе несколько

            перфиксы - символы стоящие в начале образа
            суффиксы - символы из конца образа

            3) длина префиксов и суффиксов может быть любой кроме равной длине образа

            4) метод основан на сравнении префиксов и суффиксов одинаковой длины

            Дан образ: abcabcd
            префиксы: a ab abc abca ... abcabc
            суффиксы: d cd bcd ... bcabcd

            5) перфикс и суффикс может рассматриваться не только от образа, но и от любой части образа
            например части abc
            префиксы - a ab
            суффиксы - c bc

            6) создаём массив в котором размещаются значения равные максимальной длине префмкса и суффикса при этом эта длина состоит из элементов, конечным символом которой является тот, для которого составляется перфикс функция, для первого префикс функция равна нулю

            d[0] = 0
            (a b) c a b c d  a!=b => d[1] = 0
            0 0 
            (a b c) a b c d  a!=c => ab!=bc => d[2] = 0
            0 0 0 
            (a b c a) b c d  a==a => ab!=ca => abc!=bca => d[3] = 1
            0 0 0 1
            (a b c a b) c d  a!=b => ab==ab => cab!=abc => abca!=bcab => d[4] = 2
            0 0 0 1 2

            и т д получаем

            a b c a b c d
            0 0 0 1 2 3 0

            7) ищем совпадения символов образа и строки, если они совпадают, то сравниваем следующий символ, и двигаемся по строке и образу вправо. Если не совпадают, то смотрим предыдущий, смотрим в массив и уходи на индекс, который указан в массиве по этому символу, и сравниваем элемент с этим индексом с символом в этой строке

--------------------------------------------------------------------------------
!Лабы:
!    сложные: естественного, многофазная
!    кнута-морриса-прата
!    Лаба 11.2 в группе вариант 20, данные к варианту, ключ, хэш-функция, решить двумя методами H(k) = [M*(k*A mod 1)]
!    k - передаваемый параметр(число)
!    mod1 = функция возвращающая дробную часть
!    0<A<1
!    [] - приведени к целому числу
----------------------------------------------------------------------------------
ВУЦ 3 этаж аэрокос, паспорт, зачётка, с 1 апреля, заявление -> направление на медкомиссию 


1 апреля - с 11:30 3 пары занятий (вестибюль 4 этажа, корпус А)

Лекция 
    Хэш-таблицы и Хэш-функции
        Хэш-таблица - это абстрактная структура данных, с функционалом массивов и списков

        Хэш-функция обрабатывает данные и на выход отдаёт значение, чтобы по нему вставить в массив

        Хэш-таблица - неупорядоченная структура данных(нет порядка следования элементов)

!        В сраднем сложность O(1)

        Хэш-таблица - это два элемента
            1) Хэш-функция - возвращающая хэш-код(в диапазоне индексов элементов)
            2) Массив для хранения данных
            3) Хэш-функция возвращает целое число, которое позволяет определить место для размещения элементов

        string arr[10];
        int x = hash("John"); // x = 4 (например)
        arr[x] = "John"; // arr[4] = John
        int y = hash("Paul"); // y = 6
        arr[y] = "Paul"; // arr[6] = Paul

!        Свойства Хэш-функции
            1) хэш-функция много, они могут быть подходящими для данной структуры, или плохими
            2) структура использует только те данные, которые обработаны хэш-функцией и получили свой Хэш
            3) поскольку значения находятся в диапазоне индексов массива, то они не должны выйти за границы хэш-таблицы
            4) Для лдних и тех же данных функция должна возвращать один и тот же хэш
            5) близкие значения должны иметь значительно разные хэши
            6) равномерное распределение данных(наименьшее число коллизий)

        Пример примитивной хэш-функции для строки

        unsigned int hash(char* str)
        {
            int sum = 0;
            for (int j = 0; str[j] != '\0'; j++)
            {
                sum += str[j];
            }

            return sum % HASH_MAX;
        }

!        Коллизия - это если хэши, при обработке через одну хэш-функцию, у разных данных совпали 
        Причины коллизии
            1) Плохо подобранная хэш-функция
            2) слишком большое кол-во данных и маленький размер таблицы
            3) чем меньше таблица и больше данных, тем больше коллизий

        Методы разрешения коллизии
            1) Линейное пробирование, метод открытой адресации(когда ячейка занята, прибавляем к хэшу + 1, пока не найдётся свободная ячейка) 
                Плюсы:
                    В среднем время решения остаётся линейным, что важно при большом числе данных
                Недостатки:
                    Данные скапливаются рядом
                    Требует стартового подбора хэш-функции

        Кластеризация - последовательность подряд идущих элементов таблицы, которые быстро увеличиваются называются кластером, которая увеличивает вероятность коллизий

        Метод цепочек

            node* hashtable[10];
            в массиве хранятся указатели на начало связного списка
            hash("Joey"); // 6
            помещаем под указателем на начало списка, Joey - начало списк
            Ключ не обязательно совпадает со значением в хэше
            hash("Phoebe"); // 6
            индекс 6 занят, указатель ячейки со значением Phoebe направляем на элемент который уже был, то есть строим список, или наоборот, Joey указывает на Phoebe

            Методом цепочек разрешение коллизии решается через список и хэш таблица становится массивом списков 


    ООП
        ООП - это способ программирования который представляет программу в виде совокупности объектов, причём объект может быть собственным типом данных для автора, кроме того используется понятие класса, которре увеличивает структурированность кода.

        Класс - это абстрактный тип данных (АТД), создаётся пользователем, это модель реального объекта в виде данных и функций 

        Объект класса(переменная класса) - называется экземпляром класса причём класс объявляется 1 раз, а объектов класса может быть несколько

        Характериситки объекта(переменные внутри класса) - поля 

        Основы ООП:
            1) Инкапсуляция
            2) Наследование
            3) Полиморфизм


        Инкапсуляция - некоторые поля скрыты от пользователя

        Спецификаторы доступа - возможность работы или не возможность работы с теми или иными полями

        Спецификаторы
            public - методы и данные класса, доступ к ним есть в любой части кода, определяют внешний интерфейс класса

            private - доступ к его полям будет только внутри этого класса, рекомендуется все данные класса делать приватными

            protected - основан на понятии наследования: потомков, предков

        Наследование - передача свойств и методов от одного класса(родителя) к другому(наследнику, то есть принцип наследования позволяет избегать повторений при описании полей классов

        Полиморфизм - применение одного и того же метода у разных объектов, а так же получать разные результаты в зависимости от тип объекта

        Объявление класса
            class имя
            {
            private:
                поля
            protected:
                поля
            public:
                поля
            };

            По умолчанию private

        Конструктор класса - инициализация объекта, находится в public
        Вызывается автоматически

            1) Конструктор и класс должны иметь одинаковое имя, класс может иметь несколько конструкторов и конструкторы можно перегружать

            2) Конструктор ничего не возвращает

            3) При отсутствии конструктора компилятор создаёт его автоматически

            синтаксис:
                Имя_класса(параметры)
                {
                    функционал
                }

            При наличии конструктора объект можно сразу инициализировать

        Конструктор копирования
            Работает через ссылку на другой объект этого же класса

            Date(const Date& d)
            {
                m_day = d.n_day;
                m_month = d.m_month;
                m_year = d.m_year;
            }

        Date date1(20, 11, 2020);
        Date date2(date1); // копия


        Деструктор - это метод класса для освобождения памяти объекта

            1) должен иметь то же имя что и класс, только перед именем знак ~
            2) не принимает аргументы
            3) не возвращает значение
            4) вызывается автоматически когда объект выходит из области видимости


        Статические члены класса - это объекты типа static, которые связаны с самим классом, а не с экземпляром
        Статические поля существуют в единственном экземпляре
        Инициализировать при объявлении нельзя 

        Объявление
            static тип имя;

        Синтаксис
            тип имя_класса::имя_поля = значение;

        Указатель this - указатель на адрес экземпляра класса, чтобы в дальнейшем обращаться

        math.add(7).sub(3).mult(2); - вот так

        Дружественная функция
            имеет доступ ко всем полям класса, опиывается вне класса, поэтому не является его методом
            Может быть глобальной функцией 
            Может быть методом другого класса

            Необходимо описать её в теле класса как friend
            в параметры передаётся ссылка на объект

            пример:
                class Name
                {
                    ...
                    friend void reset(Name* name);
                };
                void reset()
                {
                    можно обратиться ко всем защищённым и другим переменным класса
                }

        Дружественные классы
            имеют доступ ко всем полям другого класса

            внутри класса необходимо написать
                friend class имя_класса

        В файле .h - определение классов, а реализация в .cpp
        а потом в файле .cpp #include "name.h"
        в другом файле пишем весь функционал
        #pragma once - единожды компилировать

        и в main.cpp пользуемся классом

Лекция
    Дружественные функции и классы

        Дружественные функции - не является компонентом класса, имеет доступ к защищённым и собственным компонентам, определяется в класса со спецификатором friend

        например обнулить точку вне класса

        Дружественная функция при вызове не получает указатель this

        Объекты класса должны передаваться дружественной функции только через параметр

        Не может быть компонентной функцией того класса, по отношению к которому определяется как дружественная

        Может быть глобальной функцией

        может быть компонентной функцией другого ранее определённого класса

        Класс человек и класс фрукт, и функция съесть фрукт у человека

    Дружественные классы

        Дружественный класс должен быть другом другому классу

        Все медобы дружественного класса будут дружественны(доступны) для другого класса

        Дружественный класс должен быть определён вне тела класса который предоставляет дружбы

        Перегрузка операторов:
            Есть множество операций которые применены к данным определённого типа, чтобы операторы могли взаимодействовать с собственным классом, необходимо перегрузить операторы

            Перегрузка операторов определяет действия которые выполняет оператор

            Перегрузка это создание функции: в названии ключевое слово operator и содержит символ перегружаемого оператора

            Может быть определена как: член класса, вне класса, дружественная функция

            синтаксис:
                тип_возвр_данных operator знак_оператора(параметры)
                {
                    ...
                    return тип;
                }

            Унарная операция - 1 переменная
            Бинарная - 2 переменных

            Они могут быть определены способами:
                1) как компонентная функция без параметров или с 1 параметром
                2) как глобальная функция с 1 или 2 параметрами

        Унарные операторы:
            перегрузка:
                компонентнная
                тип operator знак()
                {
                    ...
                    return тип;
                }
                как глобальная
                тип operator знак(class&)
                {
                    ...
                }

            существуют в префиксе(без параметров) и в постфиксе(с параметром)
            Префиксные

        Бинарные операторы:
            При перегрузке операторов стоит учитывать приоритет и ассоциотивность

            Приоритет операторов задаёт порядок операций в выражениях, содержащих более одного оператора

            Ассоциативность определяет порядок выполнения нескольких операторов с одинаковым приоритетом(слева или справа)

        Перегрузка ввода вывода
            friend ostream& operator << (ostream& os, const vect& a);


            ostream& operator << (ostream& os, const vect& a)
            {
                os << "x = " << a.x;
                return os;
            }

            friend istream& operator >> (ostream& is, const vect& a);

            istream& operator >> (ostream& is, const vect& a)
            {
                is >> a.x >> a.y;
                return is;
            }

        Особенности перегрузки оператора =
            1) оператор не наследуется
            2) если оператор не перегружен, то он используется по умолчанию для каждого класса через операцию побитвого копирования того объекта который стоит справа в объект который стоит слева от операции
            3) Операция может перегружаться в качестве функции компонент класса

            Необходимо перегружать =, ведь без этого после присваивания объект которому присвоили будет ссылаться на адрес объекта который присваиваем

            А так же, если память была динамической, произойдёт утечка памяти

            Оператор присваивания ассоциативен справа налево a = (b = c)

        Перегрузка оператора индексации

            int& operator [] (const char& coord);

            int& point::operator [] (const char& coord)
            {
                if (coord == "x")
                {
                    return this->x;
                }
                if (coord == 'y')
                {
                    return this->y;
                }
            }


    Наследование классов C++
        Наследование это механизм описания нового класса(потомка) на основе существующего класса(родителя) 

        от которого наследуется - базовый класс, класс родитель

        новый класс - потомок, наследник, дочерний класс

        Наследование стоит применять в том случае, если классы связаны смыслово через методы и параметры(класс животных и класс кошек), в классах должна просматриваться иерархия

        Синтаксис:
            class name_class: specificator(private, public) family_class {};

        Пример наследования
            class Animals
            {
                ...
            };

            class Cat: public Animals
            {
                ...
            };

        private при наследовании не передаётся, protected передаётся

        Правила спецификаторов при наследовании
            public Правила
                1) Все public элементы базового класса становятся public в дочернем
                2) Все protected элементы базвого становятся protected в дочернем
                3) private элементы не передаются в дочерний класс

            protected правила
                1) public -> protected
                2) protected -> protected
                3) private не передаются

            private правила
                1) public -> private
                2) protected -> private
                3) private не передаются

        Если не указывать спецификатор: то будет использован private (это если класс наследуется от класса)

        Если класс наследуется от структуры, то по умолчанию public

        Переопределение спецификаторов внутри класса
            private не переопределяется
            Синтаксис
                новый_тип_доступа:
                using имя_базового_класса::имя_класса

        Конструкторы/деструкторы при наследовании
            Обращение дочерних классов к конструкторам родительких классов работает по принципу изнутри наружу

            Вызов конструкторов работает по принципу снаружи внутрь

            Обращение и вызов деструкторов работает по принципу изнутри наружу

        Особенности конструкторов/деструкторов
            1) Конструкторы/деструкторы не наследуются
            2) Конструкторы вызываются начиная с базового класса и заканиваются последним дочерним
            3) Деструкторы вызываются наоборот
            4) При создании дочернего класса иниацилизация элементов идет через конструктор родительского класса
            5) Когда конструктор/деструктор не указаны они применяются по умолчанию, что приводит к появлению мусора

        Обращение из дочернего класса к конструктору
            B: A(x, y) {};

Лекция
    Абстрактные классы, виртуальные функции

        Виртуальная функция - функция которая в дочерних классах переопределяется
        Используется тогда когда в дочернем классе требуется свой вариант этой функции

        Классы которые включают в себя такие функция - полиморфные классы

        Полиморфизм - возможность функции изменять возвращаемое значение

        Виртуальные функции(ВФ) - используют механизм позднего связывания(отложенного связывания), динамическое связывание

        Ключевое слово virtual перед функцией

        Свойства вирутальной функции
            1) могут быть как в базовых так и дочерних классах
            2) Если ВФ не переопределить в дочернем классе, то она останется вирутальной
            3) если переопределяется ВФ в дочерних классах, то она становится не виртуальной

        Раннее и позднее связвание
            Раннее - программа на этапе компиляции знает что выведет функция
                print(5);
            Позднее - объект связывается с функцией на этапе работы программы
                print(a);
                Плюсы: гибкость
                    Разные объекты могут иметь свой интерфейс

        Переоределение ВФ

            Полиморфизм = наследование + виртуальные функции

            Чтобы в дочернем классе переопределить ВФ, при объявлении функции указывается оператор переопределения override, после функции

        Особенности ВФ
            1) Виртуальность наследуется
            2) Виртуальными могут быть только не статические функции

        Чисто ВФ
            Это функции которые не имеют определения 
            Вирутальная функция превращается в чистую если при объявлении приравнять к нулю

            virtual void print() = 0;

            Чисто ВФ должны быть опеределены во всех классах наследниках, если этого не сделать, то наследники становятся абстрактными классами

        Абстрактные классы
            АК - содержит хотя бы одну чисто виртуальную функцию без переопределения

            Особенности АК
                Нельзя использовать когда идёт явное приведение типов, а так же для описания типа параметров и типа значения которое возвращает функция

                Допускается определять ссылки и указатели на классы наследники абстрактного класса

                Если класс, производный от абстрактного не определяет все чистые ВФ, он так же является абстрактными

                Полиморфные функции - функция которые могут опрабатывать функции разных типов

        Виртуальный деструктор
            
        Шаблоны
            Создание функции, класса, которые работают с разными типами данных

            Свойства шаблонов
                Создают семейство функций и классов
                Создание функций и классов автоматизируется(единый алгоритм для данных разного типа)

                Параметр шаблона - тип данных

                Шаблоны функций и классов называются параметризованными шаблонами

                Реализация шаблонов функций и классов называется обощённым программированием

        Шаблоны функций
            Описание функции без типа, тип - параметр

        Перегрузка шаблонов

            template <typename T>
            void swap(T& a, T& b)
            {
                ...
            }

            template <typename T>
            void swap(T& a[], T& b[], int n)
            {
                ...
            }

        Шаблоны классов 
            Для построения родового класса
            Это семейство классов, которые работают с данными разного типа
            АТД используется в качестве параметра шаблона
            Имя класса является параметризованным именем для всего семейства классов
            Инстанцирование шаблона - это генерация компилятором определения отдельного класса по шаблону и параметрам

            template <typename(class) name_type>
            class Stack
            {
                ...
            };

            Если не будет создан экземпляр шаблонного класса, то компилятор не будет генерировать шаблонный класс

            Создание экземпляра

            Stack<Type> name;


Практика

    Программа управляемая событиями
        Событие - это ситуация которая может быть при определённых условиях
        Программист предусматривает вызов обработчика для этого события через отдельные поля объекта 
        ООП программа - управляется событиями
            а) События не производят действия, а вызывают их
            б) обработка данных реализуется объектами программы, а события управляют

        Стуркутра сообщения которое передаётся от одного объекта к другому
            а) Код класса сообщения
            б) Адрес объекта которому отправляется сообщение, если его нет, то сообщение для всех объектов
            в) информационное поле

        Объединения
            Это структура, все элементы находятся по одному адресу
            Размер union равен размеру наибольшего элемента
            union MyUnion
            {
                char a; // 1
                short int b; // 2
                int c; // 4
            };

        Анонимные объединения
            Не имеют названия, не порождают объекты
            struct name
            {
                unoin
                {
                    int x;
                    double y;
                };
            };


        Структура события 
            struct Event
            {
                int what;
                union
                {
                    MouseEvent mouse;
                    KeyboardEvent keyboard;
                    MessengeEvent messenge;
                }

            struct MouseEvent
            {
                int buttons;
                int doubleclick;
                Tpoint where;
            }

            struct KeyboardEvent
            {
                int ketCode;
                char charCode;
            }

            template <typename T>
            struct MessengeEvent
            {
                int command;
                T info;
            }

        Методы обработки событий
            Execute - реализация главного цикла обработки событий. Постоянно следит за всеми событиями и обрабатывает их
            HandleEvent - оснонойметод обработки событий, который определяет реализацию реакций на событие
            GetEvent - метод описания событий
            ClearEvent - очищает текущие события
            EndExec - завершение обработки событий

        Метод HandleEvent
            1) Вызывается обработчик событий для базового класса
            2) Если событие не обработано, пункт 3
            3) В зависимости от кода команды, обрабатывается сообщение или очищается

        Цикл обработки событий в методе Execute
            1) EndState = 0; нужна для выхода из программы, если = 1, то выход
            2) получить событие
            3) обработка события
            4) если не обработано - выдать ошибку
            5) Повторить действия 1-4 пока EndState != 1

Практика
    
    Исключения C++
        Это ситуация которая не предусмотрена в базовом алгоритме

        Ход обработки исключений
            1) обнаружение
            2) передача управления обработчику исключений
            3) выполнение алгоритма обработчиком
        Обработчик - это часть кода которому передаётся управление в случае ошибки

        Синтаксис
            try
            {
                // то что нужно обработать
                throw()
                // проброс исключение, передаётся catch
            }
            catch()
            {
                //обработка
            }

        Блок try используется для проверки возникновения исключения
            Все переменные внутри try действуют локально

            Может работать с нескольким catch

        Оператор throw передаёт исключении в один из catch в случае определённой ошибки

        catch принимает код
            синтаксис

        try
        {
            if index < 0
                throw 1;
            if index > 4
                throw '2';
            cout << "successful: " << a[index] << endl;
        }
        catch (int)
        {
            cout << "< 0";
        }
        catch (char)
        {
            cour << "out of range";
        }

        Исключения обрабатываются через класс exception
        Это базовый класс для всех стандартных исключений

        class MyException : public exception
        {
            public:
                const char* what() const noexcept override
                {
                    return "Пользовательское исключение";
                }
        }

Практика

    Потоковые классы
        Это объектные функции ввода-вывода, где источник и приёмник данных - объкт

        Особенности:
            Обмен данными происходит через буфер, то есть спец хранилище для временного хранения данных
            Из буфера данные попадают в оперативную память с помощью потоковых классов

    Виды потоковых классов
        1) общие потоковые классы для вывода в консоль(iostream), классы istream, ostream
        2) для работы с файлами (fstream),классы - ifstream, ofstream
        3) классы для строковых объектов (istringstream, ostringstream)

        Все эти классы связаны наслеованием

    Наследование потоковых классов
        1) Родительским классом является класс ios, первый уровень наследования
        2) второй уровень наследования - это 4 класса
            (istream, fstreambase, strstreambase, ostream)
        3) 3 уровень населования
            (ifstream, istrstream, iostream, ostrstream, ofstream)
        4) 4 уровень наследования
            (fstream, strstream)

    Стандартные потоки ввода, вывода
        cin, cout - вход-выход через буфер(istream, ostream)
        cerr - небуферизированный выходной поток(ostream) - сообщает об ошибках
        clog - аналог cerr, но с буфером

        Операции для потоковых ввода-вывода
            <<, >> - ввод-вывод в поток

    Форматы ввода-вывода
        класс - ios управляет параметрами форматрования вывода через флаги и манипуляторы

        Флаги форматирования
            Флаг - это набор из типа enum в классе ios, переключатели

            cout.setf(ios::flag); // включаение флажка
            cout.unsetf(ios::flag); // выключение

        Флаги группы форматирования basefield
            Можно изменять системы счисления выводимых чисел

        Манипуляторы - вставляются в поток в виде инструкции, ключевого слова
        Подключается (iomanip)
        cout << setiosflags(ios::scientific) << 123.2 << endl;

        Набор флагов и манипуляторов
            флаги floatfieald
                fixed - запись числа с плавающей точкой
                scientific - экспонинцеальная запись числа
                showpoint - можно задавать точность

            Манипуляторы
                fixed
                scientific
                showpoint
                noshowpoint - не отображаются числа после точки
                setprecision(int) - задание точности числа

            Методы
                precision() - возвращает заданную точность

            Флаги adjustfield
                internal - выравнивание знака слева и число справа
                left - выравнивают слева
                right - справа

            Манипуляторы
                internal
                left
                right
                setfill(char) - задаём символ заполнитель
                setw(int) - задание ширины поля

            Методы
                fill() - возвращаем символ заполнитель
                fill(char) - задаём новый символ заполнитель
                width() - возвр. текущую ширину поля
                width(int) - изменяем текущую ширину поля

        Пользовательские манипуляторы
            вывода
            ostream& имя_манипулятора (ostream& os)
            {
                //код
                return os;
            }

            ввода
            просто вместо ostream - istream

        Плюс манипуляторов - объединение нескольких операций ввода-вывода в один манипулятор, необходими для ввода вывода на нестандартном оборудовании

        Состояние потока
            метод stream.rdstate() - возвращает значение типа int
            0 - нет ошибки
            1 - конец потока
            2 - не выполнилась последняя операция
            4 - попытка использования недопустимой операции
            8 - фатальная ошибка

            ifstream stream = ifstream()
            stream.fail()
            steam.bad()
            stream.eof()
            stream.good()

    Неформатированный ввод
        1. метод get(char* buffer, int size, char delimeter = '\n')
        2. метод getline(char* buffer, int size, char delimeter = '\n')
        3. gcount() - кол-во символов в потоке
        5. putback() - символ в конец потока
        6. ignore(int n) - игнорирует n символов с начала потока
        7. put(char c) - добавляет символ в начало потока
        8. write(char* str, int size) - запишет size символов из буфера в поток
        9. telleg() - местоположение указателя потока(индекс)
        10. seekg() - устанавливает указатель в байтах от начала потока

    режимы открытия файла
        ios::in - чтение
        ios::out - перезапись
        ios::ate - после открытия указатель в конец
        ios::app - 
        ios::binary

        их можно совмещать передавая в параметры (ios::in | ios::ate)
        
Лекция 
    
    Бинарные деревья
        Дерево - это нелинейная структура, форма - связанные узлы

        Узел - хранит данные, имеет указатели на связанные с ним узлы

        Дочерний узел - связан с узлом верхнего уровня по указателю

        Родительский узел - узел верхнего уровня, связан с потомками указателями

        Корневой узел - узел не имеющий родительских узлов

        Лист - узел не имеющий потомков 

        Высота дерева - кол-во уровней

    Использование бинарного дерева  
        если Информация хранится в некоторой иерархией

    Методы обхода дерева
        1) Прямой
        2) Симметричный
        3) Обратный

    Прмой
        1. обработать корень
        2. обойти левое поддерево
        3. обойти правое поддерево
    Симметричный
        1. обойти левое
        2. корень
        3. правое
    Обратный
        1. левое
        2. правое
        3. корень

    Идеально сбалансированные дерево
        Когда для каждого узла левого и правого поддерева их кол-во отличается не более чем на 1 узел (минимальная высота log(n) + 1)

    Бинарное дерево поиска
        Это когда дерево обладает доп свойствами
            Значение левого потомка всегда меньше родителя, а значение правого потомка всегда больше
-------------------------------------------------------------------------------
!Сделать UML диаграмму классов, осуществить все виды обходов, реализоать операции: вставка узла, удаление узла, поиск элемента по ключу; визуализировать дерево(OpenGL, SFML, SDL), пользовательский интерфейс разработать самостоятельно через windows forms; в отчёте дополнить содержание: анализ задачи с разбором применения используемых структур данных и функций, в коде программы на C++ сделать подробные комментарии, скриншоты работы программы, визуализация решения.
-------------------------------------------------------------------------------
Только 13 лаба

    Последовательные контейнеры в STL

        STL - состоит из набора контейнерных классов и обобщённых алгоритмов

        Контейнер - объект который содержит другие объекты одного типа

        Обобщённые алгоритмы - реализуют поиски, сортироки, слияние, и другие методы

    Контейнеры
        Последовательные:
            Основные: вектор, двунаправленная очередь, спиок
            Адаптеры: стек, очередь, очередь с приоритетом

        Ассоциативные: словари, множества, словари с дубликатами, множества и дубликатами

        Адаптеры - основаны на основных контейнерах

    Функциональный объект - объект в котором перегружен ()

    Продвинутые указатели позволяют указывать, на функции
    библиотека <functional>
