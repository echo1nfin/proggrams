Методы строк:
	1) Метод .upper
	Данный метод возвращает новую строку из строки S, превращает все буквы в заглавные. Если в строке будут присутствовать символы или цифры, то они останутся неизменными. Цифры и знаки пунктуации игнорируются.

	2) Метод .lower является противоположным методу .upper . Данный метод возвращает новую строку из строки S, превращает все буквы в строчные(нижний регистр). Если в строке будут присутствовать символы или цифры, то они останутся неизменными.

	3) Метод .title возвращает новую строку, в которой каждое слово исходной строки начинается с буквы в верхнем регистре, а все остальные буквы в нижнем. Цифры и знаки пунктуации игнорируются.

	4) Метод .capitalize возвращает новую строку, в которой только первый символ находится в верхнем регистре, а все остальные в нижнем. Цифры и знаки пунктуации игнорируются.

	5) Метод .swapcase возвращает новую строку, в которой  все заглавные буквы преобразованы в строчные, строчные – в заглавные. Цифры и знаки пунктуации игнорируются.

	6) Метод .find возвращает индекс первого слева вхождения строки sub в строке S. Подстрока sub ищется на всем срезе строки S. Но вы можете указать интервал поиска, передав второй и третий аргументы. Метод .find вернет значение -1, если ничего не будет найдено. 
	(S.find(sub[, start[,end]]))

	7) Если вам необходимо искать с другого конца вашей строки то в таком случае можно использовать аналогичный метод rfind(). Буква r обозначает слово right(справа) и, следовательно, поиск будет идти справа. Вы также можете ограничить интервал поиска, передав дополнительно параметры start и end

	8) Метод  .index также возвращает индекс первой найденной подстроки, аналогично методу .find 

	9) Метод .startswith  имеет следующий шаблон вызова:

		S.startswith(prefix[, start[, end]])

		Данный метод возвращает True если строка S начинается с последовательности символов prefix (префикса) и False в противном случае.  При передаче параметра start проверка начнется именно с этой позиции. Если передать значение  end, проверка закончится в этой позиции.

	10) Метод endswith() имеет следующий шаблон вызова:

		S.endswith(prefix[, start[, end]])

		Данный метод возвращает True если строка S заканчивается последовательностью символов prefix (префикса) и False в противном случае.  При передаче параметра start проверка начнется именно с этой позиции. Если передать значение  end, проверка закончится в этой позиции.

	11) Метод .ljust а так же .rjust имеет следующий шаблон вызова:

		S.ljust(width[, fillchar])

		Метод  .ljust принимает один обязательный параметр width - ширину строки и один необязательный параметр fillchar - знак заполнителя (по умолчанию пробел) . Возвращает новую строку, в которой исходная строка S дополнена справа символами fillchar до указанной длины width. Если параметр width меньше длины строки, то будет возвращена исходная строка без изменений:

	12)  Метод .center  имеет следующий шаблон вызова:

		S.center(width[, fillchar])

		Метод .center принимает один обязательный параметр width - ширину строки и один необязательный параметр fillchar - знак заполнителя (по умолчанию пробел) . Возвращает новую строку длины width, в которой исходная строка S находится в центре, а справа и слева от нее находятся символы fillchar . Если параметр width меньше длины строки, то будет возвращена исходная строка без изменений. 

	13) Метод .zfill  имеет следующий шаблон вызова:

		S.zfill(width)

		Метод .zfill возвращает новую строку, в которой исходная строка S дополнена нулями слева так, чтобы длина новой строки стала равна width.

	14) Метод  .strip(symbols) ещё есть .rstrip и .lstrip возвращает копию строки, удаляя как начальные, так и конечные символы (в зависимости от переданного строкового аргумента). Метод удаляет символы как слева, так и справа в зависимости от аргумента chars . Если аргумент chars не передан, то по умолчанию удаляться пробелы и символы переноса на новую строку \n.

	15) Метод  .partition разбивает строку по указанному разделителю и возвращает кортеж из трех элементов: строка до разделителя, сам разделитель и строка после разделителя. Если разделитель не найден, то возвращается кортеж так же состоящий из трех элементов в котором первый элемент – это исходная строка S, а два других элемента – это пустые строки.

	16) Метод  .rpartition разбивает строку по последнему встреченному разделителю sep и возвращает кортеж, который состоит из трех элементов: строки до разделителя, самого разделителя и строки после разделителя. Если разделитель в строке отсутствует, то кортеж будет состоять из: двух пустых строк и исходной строки

F-строки:
	1) print(f'{c:.3f}')
		Запись c:.3f говорит, что  переменную c нужно представить в вещественном виде (это знак f) и отобразить три символа после запятой. Если у переменной c не хватает символов для трех знаков, проставятся нули. Если символов в избытке, произойдет округление до третьего символа после запятой.

	2) print(f'{n:7d}')
		Запись n:7d говорит, что  переменную n нужно представить в виде целого числа (это знак  d ) и на отображение всего числа выделить 7 знаков. Если у переменной n не хватает разрядов до семи, то впереди отображения появятся знаки пробелов. 

		Можно вместо пробелов добавить незначащие нули, для этого нужно подписать 0 перед количеством разрядов: print(f'{n:07d}')

	3)  n = 12345678912345
		print(f'{n:_d}')
		output: 12_345_678_912_345

	4) Символ 	Значение
	< 	Выравнивает выражение в фигурных скобках по левому краю. У строк такое поведение по умолчанию
	> 	Выравнивает выражение в фигурных скобках по правому краю. У чисел такое поведение по умолчанию
	^ 	Выравнивает выражение в фигурных скобках по центру
		print(f"|{number:>25}|")
		print(f"|{number:^25}|")
		output: |               12345.6789|
				|       12345.6789        |

	ещё: print(f"|{number:=^25}|")
		 output: |=======12345.6789========|
		 